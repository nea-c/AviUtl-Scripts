--track0:ｸﾞﾗﾌｻｲｽﾞ,50,1000,500,1
--track1:グラフ表示,0,1,1,1;
--dialog:anchor,_1={-50,50,50,-50};param,_2=nil;出力時描画/chk,_3=0;
--check0:クリップボードにコピー,0;

local ease = require "ease"
local common = require "ease_common"

local function copy_clipboard()
	obj.setfont("メイリオ",30)
	local mes="LuaJIT非導入下であるためこの機能は使えません"
	obj.load("text",mes)
	obj.draw(0,0,0,obj.screen_w/obj.getpixel()*0.8)
	error("[ease_graph] "..mes,0)
end
if (common.ffi) then
	local ffi = common.ffi
	local C = ffi.C

	copy_clipboard = function(str)
		if (C.OpenClipboard(0) == 0) then
			return
		end
		C.EmptyClipboard()
		local hg = C.GlobalAlloc(0x2042, #str + 1)
		local buf = C.GlobalLock(hg)
		ffi.copy(buf, str)
		C.GlobalUnlock(hg)
		C.SetClipboardData(1, hg)
		C.CloseClipboard()
	end
end
local floor = math.floor
local function clamp(x, mn, mx)
	return x < mn and mn or x > mx and mx or x
end
local function drawLine(x1, y1, x2, y2, width)
	local dx, dy = x2 - x1, y2 - y1
	local s = width * .5 / math.sqrt(dx * dx + dy * dy)
	dx, dy = dx * s, dy * s
	obj.drawpoly(x1 + dy, y1 - dx, 0, x2 + dy, y2 - dx, 0, x2 - dy, y2 + dx, 0, x1 - dy, y1 + dx, 0)
end
local function toparamstr(x1, y1, x2, y2)
	return string.format("%02d%02d%02d%02d", x1, y1, x2, y2)
end

local function Orbit(t, x1, y1, x2, y2)
	local s = 1 - t
	x1 = (3 * s * s * x1 + (3 * s * x2 + t) * t) * t
	y1 = (3 * s * s * y1 + (3 * s * y2 + t) * t) * t
	return x1, -y1
end

local size = obj.track0
local is_display_graph = obj.track1 ~= 0
_1 = _1 or {-50, 50, 50, -50}
local x1a, y1a, x2a, y2a = unpack(_1)
local is_copy_clipboard = obj.check0
local param_user = _2
local show_also_saving = _3 ~= 0
local _error = false

local sd2 = size * .5

obj.setfont("メイリオ", size * .1)
local x1p, y1p, x2p, y2p, paramstr
if (param_user) then
	paramstr = tostring(param_user)
	y2p = param_user % 100
	param_user = math.floor((param_user - y2p) * 0.01)
	x2p = param_user % 100
	param_user = floor((param_user - x2p) * 0.01)
	y1p = param_user % 100 or 25
	x1p = floor((param_user - y1p) * 0.01)
	--paramstr = toparamstr(x1p, y1p, x2p, y2p)
	if not (25 <= x1p and x1p <= 75) or not (25 <= x2p and x2p <= 75) then
		paramstr = "ERROR"
		x1p, y1p, x2p, y2p = 45, 45, 55, 55
		_error = true
	end
	if not (obj.getinfo "saving") then
		if (is_copy_clipboard) and (not _error) then
			copy_clipboard(paramstr)
		end
	end
else
	obj.setanchor("_1", 2)

	x1p = clamp(floor(.5 + 50 + x1a / sd2 * 25), 25, 75)
	y1p = clamp(floor(.5 + 50 - y1a / sd2 * 25), 0, 99)
	x2p = clamp(floor(.5 + 50 + x2a / sd2 * 25), 25, 75)
	y2p = clamp(floor(.5 + 50 - y2a / sd2 * 25), 0, 99)

	paramstr = toparamstr(x1p, y1p, x2p, y2p)
	if not (obj.getinfo "saving") then
		if (is_copy_clipboard) then
			copy_clipboard(paramstr)
		end
	end
end

if (obj.getinfo "saving" and not show_also_saving) or (not is_display_graph) then
	return
end

obj.setoption("drawtarget", "tempbuffer", size + 20, size * 2 + 20)

obj.load("figure", "四角形", 0x231d1e, size)
obj.draw(0, 0, 0, 1, 0.5)
obj.load("figure", "四角形", 0xd7d3d4, size, 1)
obj.draw()

obj.load("四角形", 0xffffff, 1)
local bezier = ease.bezier((x1p - 25) * .02, (y1p - 25) * .02, (x2p - 25) * .02, (y2p - 25) * .02)
local before = bezier(0, sd2, -sd2)

for i = 1, 100 do
	local tmp = bezier(i * .01, sd2, -sd2)
	drawLine((i - 51) * .01 * size, before, (i - 50) * .01 * size, tmp, 2)
	before = tmp
end

obj.load("text", paramstr, 4, 0xd7d3d4, 0x231d1e)
obj.draw(0, 0, 0, 0.8, 0.8)

obj.load("figure", "四角形", 0xffffff, 1)
obj.effect("領域拡張", "塗りつぶし", 1, "右", ((size * size) * 2) ^ 0.5)
obj.draw(0, 0, 0, 1, 0.2, 0, 0, -45)

local x1af = (x1p - 50) / 25 * sd2
local y1af = (y1p - 50) / 25 * -sd2
local x2af = (x2p - 50) / 25 * sd2
local y2af = (y2p - 50) / 25 * -sd2

obj.load("figure", "四角形", 0xff471c, 1) --0xd7d3d4
local length = ((-sd2 - x1af) ^ 2 + (sd2 - y1af) ^ 2) ^ 0.5
local rot = math.deg(math.atan2(sd2 - y1af, -sd2 - x1af))
obj.effect("領域拡張", "塗りつぶし", 1, "右", length * 2)
obj.effect("斜めクリッピング", "角度", -90)
obj.draw(-sd2, sd2, 0, 1, 0.7, 0, 0, rot)

obj.load("figure", "四角形", 0xff471c, 1)
local length = ((sd2 - x2af) ^ 2 + (-sd2 - y2af) ^ 2) ^ 0.5
local rot = math.deg(math.atan2(-sd2 - y2af, sd2 - x2af))
obj.effect("領域拡張", "塗りつぶし", 1, "右", length * 2)
obj.effect("斜めクリッピング", "角度", -90)
obj.draw(sd2, -sd2, 0, 1, 0.7, 0, 0, rot)

local section_number = obj.getoption("section_num")
local section_time = {}

section_time[0] = obj.getvalue("time", 0, 0)
section_time[section_number] = obj.getvalue("time", 0, -1)
local obj_time = obj.time

local z = (obj_time - section_time[0]) / (section_time[section_number] - section_time[0])
local t1 = 0
local t2 = 1

local x1af_per, y1af_per, x2af_per, y2af_per =
	(x1af + sd2) / size,
	(-y1af + sd2) / size,
	(x2af + sd2) / size,
	(-y2af + sd2) / size

for i = 1, 10 do
	local tm = (t1 + t2) * 0.5
	local xm, y = Orbit(tm, x1af_per, y1af_per, x2af_per, y2af_per)
	if z < xm then
		t2 = tm
	else
		t1 = tm
	end
end

local x, y = Orbit((t1 + t2) * 0.5, x1af_per, y1af_per, x2af_per, y2af_per)

x = x * size - sd2
y = (y * size + sd2)
if (not _error) then
	obj.load("円", 0xff471c, 20)
	obj.effect("縁取り", "サイズ", 1, "color", 0xffffff)
	obj.draw(x, y, 0, 0.5, 1)

	obj.load("円", 0x00ff00, 20)
	obj.effect("縁取り", "サイズ", 1, "color", 0xffffff)
	obj.draw(sd2, y, 0, 0.5, 1)
end
obj.load("円", 0xff0088, 20)
obj.effect("縁取り", "サイズ", 1, "color", 0xffffff)
obj.draw(x1af, y1af, 0, 0.8)
obj.load("円", 0x00aabb, 20)
obj.effect("縁取り", "サイズ", 1, "color", 0xffffff)
--obj.effect("単色化","color",0xff00,"輝度を保持する",0)
obj.draw(x2af, y2af, 0, 0.8)

--obj.load("figure", "円", 0xff471c, 20)
--obj.effect("縁取り", "サイズ", 1, "color", 0xffffff)
--obj.draw(x, y, 0, 0.5, 1)

obj.load("tempbuffer")
--obj.setoption("focus_mode","fixed_size")
