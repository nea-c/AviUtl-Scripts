--track0:offset,-1000,1000,0,0.01
--track@rzPlus:回転,-180,180,0,0.01
--track2:字間倍率,-9000,9000,100,0.01
--track@anchor_amount:次数,2,99,3,1
--check@fix:向く,1
--check@guide_visible:ガイド,1
--track@line_sizeD:ｶﾞｲﾄﾞ線幅,1,1000,3,1
--track@handle_sizeD:ﾊﾝﾄﾞﾙｻｲｽﾞ,1,1000,15,1
--check@guide_saving_disable:出力時ガイド非表示,1
--value@anchors:---,{0,0,0,0,0,0,0,0}


local function f()
    --////////////////////////////////////////////////////////////////////////////////////////////
    local function bezier(ti, p0, p1)
        local returnData = { x = 0, y = 0 }
        returnData.x = (1 - ti) * p0.x + ti * p1.x
        returnData.y = (1 - ti) * p0.y + ti * p1.y
        return returnData
    end
    --/////////////////////////////////////////////////////////
    local function get_length(a, b)
        return math.sqrt((b[1] - a[1]) ^ 2 + (b[2] - a[2]) ^ 2)
    end
    --/////////////////////////////////////////////////////////
    local function anchor_adjust(point, zoom)
        local point_return = {}
        for i = 1, #point / 2 do
            point_return[i] = { x = 0, y = 0 }
            point_return[i].x = (point[i * 2 - 1] * zoom / 100)
            point_return[i].y = (point[i * 2] * zoom / 100)
        end
        return point_return
    end
    --/////////////////////////////////////////////////////////
    local function linear_time_bezier_table(point, density)
        local p1 = {}
        local check = {}
        check[0] = { point[1].x, point[1].y }
        local l = {}
        l[0] = 0
        local ji = #point - 1
        local t
        for n = 0, density do
            t = n / density
            for i = 1, ji do
                p1[i] = bezier(t, point[i], point[i + 1])
            end
            for i = 1, ji do
                for j = 1, ji - i do
                    p1[j] = bezier(t, p1[j], p1[j + 1])
                end
            end
            check[n + 1] = { p1[1].x, p1[1].y }
            l[n + 1] = l[n] + get_length(check[n + 1], check[n])
        end

        local curve_length = l[#l]
        for i = 0, #l do
            l[i] = l[i] / curve_length
        end

        return l
    end
    --/////////////////////////////////////////////////////////
    local function linear_time_bezier(ti, point)
        local l = point
        local i1 = 1
        local i2 = #l
        local im = -1

        while (i1 < i2) do
            im = math.floor((i1 + i2) / 2)
            if (ti < l[im]) then
                i2 = im - 1
            else
                i1 = im + 1
            end
        end

        local ratio = (ti - l[im]) / math.max(l[im + 1] - l[im], 1e-5)
        return (im * (1 - ratio) + (im + 1) * ratio) * (1 / #l)
    end

    --/////////////////////////////////////////////////////////////////////////////////////////////

    --

    local offset = obj.track0 / 100
    local space = obj.track2 / 100 / 2

    obj.setanchor("anchors", anchor_amount + 1) --アンカー/////////////////////////////////


    local fix = fix == 1
    local pos = anchor_adjust(anchors, obj.getvalue("zoom"))
    local guide_visible = (guide_visible == 1) and (guide_saving_disable == 0 or not obj.getinfo("saving")) or false


    local zoom = 100 / obj.getvalue("zoom")
    local alpha = 1 / obj.getvalue("alpha")
    local rx = -obj.rx
    local ry = -obj.ry
    local rz = -obj.rz

    local be = { now = {}, ago = {} }


    if bezierTextTable == nil then
        bezierTextTable = {}
    end
    if bezierTextTable[obj.layer] == nil then
        bezierTextTable[obj.layer] = {}
    end

    if (not obj.getoption("multi_object")) then
        bezierTextTable[obj.layer].l = linear_time_bezier_table(pos, 10000)
    end

    local iii = offset - (1 - (obj.index + 1) / obj.num) * space
    local t0 = linear_time_bezier(iii, bezierTextTable[obj.layer].l)
    local t1 = linear_time_bezier((iii - 0.01), bezierTextTable[obj.layer].l)
    for i = 1, anchor_amount do
        be.now[i] = bezier(t0, pos[i], pos[i + 1])
        be.ago[i] = bezier(t1, pos[i], pos[i + 1])
    end
    for i = 1, anchor_amount do
        for j = 1, anchor_amount - i do
            be.now[j] = bezier(t0, be.now[j], be.now[j + 1])
            be.ago[j] = bezier(t1, be.ago[j], be.ago[j + 1])
        end
    end
    obj.ox = be.now[1].x
    obj.oy = be.now[1].y
    local deg = 0
    if fix then
        deg = math.deg(math.atan2(be.now[1].y - be.ago[1].y, be.now[1].x - be.ago[1].x))
    end
    obj.rz = -rz + deg + rzPlus


    if (iii < 0 or 1 < iii) then
        obj.draw(0, 0, 0, 0)
    else
        if (guide_visible) then
            obj.draw()
        end
    end
    --////////////////////////////////////////////////////////////////////////////////////

    --debug_print()
    --ガイドの描画//////////////////////////////////////////////
    if (guide_visible and not (obj.index > 0)) then
        local line_and_handle_color = 0x2ca9e1
        local start_color = 0x3de02d
        local end_color = math.abs(start_color - 0xffffff)
        local handle_line_color = math.abs(line_and_handle_color - 0xffffff)
        local line_size = line_sizeD or 3
        local line_density = 200
        local handle_line_view = true
        local handle_size = handle_sizeD or 15
        --ハンドルの線/////////////////////////////////////////////////////////////////////
        if handle_line_view then
            for i = 1, anchor_amount do
                obj.load("figure", "四角形", handle_line_color, line_size)
                for j = 0, line_density / 5 do
                    be[0] = bezier(j / line_density * 5, pos[i], pos[i + 1])
                    obj.draw(be[0].x, be[0].y, 0, zoom, alpha, rx, ry, rz)
                end
            end
        end
        --曲線/////////////////////////////////////////////////////////////////////
        obj.load("figure", "四角形", line_and_handle_color, line_size)
        local l = linear_time_bezier_table(pos, line_density * 100)
        for iii = 0, line_density do
            local t = linear_time_bezier(iii / line_density, l)
            for i = 1, anchor_amount do
                be[i] = bezier(t, pos[i], pos[i + 1])
            end
            for i = 1, anchor_amount do
                for j = 1, anchor_amount - i do
                    be[j] = bezier(t, be[j], be[j + 1])
                end
            end
            obj.draw(be[1].x, be[1].y, 0, zoom, alpha, rx, ry, rz)
        end
        --開始/終了座標の点/////////////////////////////////////////////////////////////////////
        obj.load("figure", "四角形", start_color, handle_size)
        obj.draw(pos[1].x, pos[1].y, 0, zoom, alpha, rx, ry, rz)
        obj.load("figure", "四角形", end_color, handle_size)
        obj.draw(pos[anchor_amount + 1].x, pos[anchor_amount + 1].y, 0, zoom, alpha, rx, ry, rz)
        --ハンドルの点/////////////////////////////////////////////////////////////////////
        obj.load("figure", "円", line_and_handle_color, handle_size)
        for i = 2, anchor_amount do
            obj.draw(pos[i].x, pos[i].y, 0, zoom, alpha, rx, ry, rz)
        end
        --数字/////////////////////////////////////////////////////////////////////
        for i = 1, anchor_amount + 1 do
            obj.setfont("メイリオ", 20, 3)
            obj.load("text", i)
            obj.draw(pos[i].x + 15, pos[i].y + 15, 0, zoom, alpha, rx, ry, rz)
        end
        --///////////////////////////////////////////////////////////////////////////////
    end
end

local a, b = pcall(f)

if a then return end
setfont("メイリオ", 30)
obj.load("text", "Error:\n" .. b:match("%[.+%]:(%d+:.*)"))
obj.draw(0, 0, 0, math.min(obj.screen_w / obj.w * 0.7, 1))
