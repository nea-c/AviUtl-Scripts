--select@mode:モード=1,ピクセル=1,割合=2
--track@xpos:X位置,-10000,10000,0,0.01
--track@ypos:Y位置,-10000,10000,0,0.01
--check@PositionLock:オブジェクト位置固定,1
--check@objCenter:オブジェクト中心,0
--track@deg:円移動,-360,360,0,0.01
--track@screenX:画面補正X(%),-10000,10000,0,0.01
--track@screenY:画面補正Y(%),-10000,10000,0,0.01
--check@guide:ガイド,1
--check@guideSavingRemove:出力時ガイド非表示,1
--color@guideColor:ガイド色,0xff0000
--track@guideSize:ガイドサイズ,0,20000,20,1
--track@guideWidth:ガイド太さ,0,200,3,1


local zoomsize = 100 / obj.getvalue("zoom")
local alpha = 1 / obj.getvalue("alpha")

local w, h = obj.getpixel()
w, h = w / 2, h / 2
local cx, cy = 0, 0
local zoom = obj.getvalue("zoom") / 100
local rz = obj.getvalue("rz")
local obj_ox, obj_oy = obj.ox, obj.oy
local obj_cx, obj_cy = obj.cx, obj.cy


if (mode == 2) then
  xpos =  w * xpos / 100
  ypos =  h * ypos / 100
end




local xyrad = math.atan2(ypos,xpos)
local l = xpos * math.cos(xyrad) + ypos * math.sin(xyrad)





cx = (deg == 0) and xpos or l * math.cos(xyrad + math.rad(deg))
cy = (deg == 0) and ypos or l * math.sin(xyrad + math.rad(deg))

cx = cx / zoom + (objCenter == 1 and obj_cx or 0)
cy = cy / zoom + (objCenter == 1 and obj_cy or 0)

if (PositionLock == 1) then
  obj.cx = obj.cx - cx
  obj.cy = obj.cy - cy
  obj.ox = obj.ox - cx
  obj.oy = obj.oy - cy
else
  obj.cx = obj.cx - cx
  obj.cy = obj.cy - cy
end

screenX = screenX / 100 * obj.screen_w / 2
screenY = screenY / 100 * obj.screen_h / 2

obj.ox = obj.ox + screenX
obj.oy = obj.oy + screenY

if(not obj.getinfo("saving")) or (guideSavingRemove == 0) then
  if (guide == 1) then
    local screenMax = math.max(obj.screen_w, obj.screen_h) * 2
    obj.setoption("drawtarget", "tempbuffer", screenMax, screenMax)
    obj.effect()
    local draw_pos_obj = { x = 0, y = 0 }
    local draw_pos_guide = { x = 0, y = 0 }
    xpos = obj_ox - obj_cx + cx
    ypos = obj_oy - obj_cy + cy
    xyrad = math.atan2(ypos, xpos)
    l = xpos * math.cos(xyrad) + ypos * math.sin(xyrad)
    draw_pos_obj.x = (obj.rz + rz == 0) and obj_ox - obj_cx + cx or l * math.cos(xyrad + math.rad(obj.rz + rz))
    draw_pos_obj.y = (obj.rz + rz == 0) and obj_oy - obj_cy + cy or l * math.sin(xyrad + math.rad(obj.rz + rz))
    if (PositionLock == 1) then
      draw_pos_guide.x = -obj_ox - cx
      draw_pos_guide.y = -obj_oy - cy
      draw_pos_obj.x = draw_pos_obj.x + draw_pos_guide.x
      draw_pos_obj.y = draw_pos_obj.y + draw_pos_guide.y
    else
    end
    obj.draw(draw_pos_obj.x, draw_pos_obj.y, 0, 1, 1, 0, 0, obj.rz + rz)
    obj.load("figure", "四角形", guideColor, 1)
    obj.effect("領域拡張","上",guideSize,"下",guideSize,"左",guideWidth,"右",guideWidth,"塗りつぶし",1)
    obj.draw(draw_pos_guide.x,draw_pos_guide.y,0,zoomsize,alpha,0,0,0)
    obj.load("figure", "四角形", guideColor, 1)
    obj.effect("領域拡張","上",guideWidth,"下",guideWidth,"左",guideSize,"右",guideSize,"塗りつぶし",1)
    obj.draw(draw_pos_guide.x,draw_pos_guide.y,0,zoomsize,alpha,0,0,0)
    obj.load("tempbuffer")
    obj.setoption("drawtarget", "framebuffer")
    obj.draw(screenX,screenY,0,zoomsize,alpha,0,0,-obj.rz - rz)
  end
end

