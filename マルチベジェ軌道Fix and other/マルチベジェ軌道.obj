--------------------------------------------------------------------------------
--track0:Editor,0,2,2,1
--track1:ポイント数,0,7,1,1
--track2:軌道番号,1,100,1,1
--track3:記録する,-1,1,0,1
--check0:三次ベジェ,1
--dialog:全て初期化/chk,local emp=0;精度,local ac=256;>,pA={-70,180,-30,140,0,0,30,-140,70,-180};出力時に非表示/chk,local hdn=1;エディタサイズ,_5=200;
--------------------------------------------------------------------------------

-- エディタのサイズ
local SIZE = _5 or 200

_5=nil

-- ベジェ曲線の精度 (100 〜 200程度) カーブが細かく変化がきつい、時間が凄く長いなどの場合は増やす
local ACCURACY = math.max(10,(ac or 256))


-- 表示フォント
local FONT = "inconsolata"

-- 0:重いグラフ 1:簡易グラフ
local SD = 1

-- 1: グラフのグラデーションon
local GRAD = 0

-- 色配置プリセット(一番上を使用)
local PALLETTE = {
	{BG=0x130909,0xe81e63,0x2195f2,0x8ac24a,0xfe5722,0x00bbd3,0xccdb39,0xfec007,0xff0048}, -- material
	{BG=0x271d15,0x8c96ac,0x991a0b,0xcac3b0,0x3f8086,0x3B876d},
	{BG=0x070a0f,0x991a0b,0xcac3b0},
	{BG=0x130909,0xe4dfde,0xbb2211,0xf0d192,0x3f8086,0x577fab},
	{BG=0x130909,0x1b3c69,0x364b5e,0x991a0b,0xbe571d,0xcac3b0},
}
PALLETTE[0] = PALLETTE[1]

local pre = 1;
--------------------------------------------------------------------------------
if (emp==1) then
	Bezier_flow = nil
end

if not (Bezier_flow) then
	
	Bezier_flow = {}
	
	-- rikky_moduleをpcallで試しに呼ぶ
	pcall(require,"rikky_module")

	-- マルチベジェ軌道.traで使用する
	function Bezier_flow.Interpolation()
		local N = obj.getpoint("param")
		local index,time = math.modf(obj.getpoint("index"))
		local s = obj.getpoint(index)
		local e = obj.getpoint(index+1)
		if not (Bezier_flow[N]) then
			return s + (e-s) * time
		end
		local i,t = math.modf(time * #Bezier_flow[N])
		return s + (e-s) * (((Bezier_flow[N][i+1] or 1) - Bezier_flow[N][i]) * t + Bezier_flow[N][i])
	end


	-- スクリプトで使う用 
	-- N=軌道番号, time=0〜1の値, 戻り値はtのイージング後の値です。
	function Bezier_flow.time(N,time)
		if not (Bezier_flow[N]) then return time end
		local i,t = math.modf(time * #Bezier_flow[N])
		return ((Bezier_flow[N][i+1] or 1) - Bezier_flow[N][i]) * t + Bezier_flow[N][i]
	end

end

--------------------------------------------------------------------------------
local function clamp(x) return (x<=0 and 0) or (x>=1 and 1) or x end
local function clampm(x,min,max) return (x<=min and min) or (x>=max and max) or x end
local function clampn(x,n) return (x<=-n and -n) or (x>=n and n) or x end
local function linear(t,a,b,A,B) return clamp((t-a)/(b-a)) * (B-A)+A end
local function col_lerp(t,c0,c1)
	local a,b = {RGB(c0)},{RGB(c1)}
	return RGB(a[1]+(b[1]-a[1])*t,a[2]+(b[2]-a[2])*t,a[3]+(b[3]-a[3])*t)
end

local zo  = obj.getvalue("zoom")*0.01
local fix = SIZE/200
local edt = obj.track0
local num = math.floor(obj.track1 + 1)         -- アンカー数
local N = math.floor(obj.track2)               -- 軌道番号
local S = SIZE * zo                            -- スケール
local W = (obj.track3)                         -- 保存モード
local B = (obj.check0 and 3) or 2              -- ベジェタイプ、配列巡回時のカウンター増加値に使う
local init = (rikky_module and obj.track3==-1) -- 配置の初期化
--------------------------------------------------------------------------------
if (B==3) then num = math.min(5,num) end

if (edt>0) then
	pA = pA or {-100,100,100,-100}
	obj.setanchor("pA",B*num-1)
	-- 配置の初期化をする
	if (init) then
		local tmp = {}
		for i=1,#pA/2 do
				tmp[i*2-1] = linear(i,0,(#pA/2+1),-S,S)
				tmp[i*2]   = - tmp[i*2-1]
		end
		for i=1,#pA do
			tmp[i] = math.floor(tmp[i]*1/zo)
		end
		if (#tmp == (B*num-1)*2) then --アンカー数変更とループ対策
		  rikky_module.setdialogparam("pA",tmp)
		end
	end
end

-- 点毎にまとめてわかりやすく？する
local p = {}
for i=1,#pA/2 do
	p[i] = {
		clampm((pA[i*2-1])*zo,-S,S),
		pA[i*2]*zo
	}
end

-- 始点と終点を追加
p[0]    = {-S,S}
p[#p+1] = {S,-S}

-- アンカーの位置入れ替え
if (B==2) then
	for i=B,#p-B,B do
		for j=i,#p-B,B do
			if (p[i][1] > p[j][1]) then
				p[i],p[j] = p[j],p[i]
			end
		end
	end
else
	for i=B,#p-B,B do
		for j=i+3,#p-B,B do
			if (p[i][1] >= p[j][1]) then
				p[i],p[j] = p[j],p[i]
			end
		end
	end
end

-- ハンドルの位置制限
if (B==2) then
	for i=0,#p-B,B do
		if (p[i+1][1] < p[i][1]) then
			p[i+1][1] = p[i][1]
		end
		if (p[i+1][1] > p[i+2][1]) then
			p[i+1][1] = p[i+2][1]
		end
	end
elseif (B==3) then
	for i=0,#p-B,B do
		if (p[i+1][1] < p[i][1]) then
			p[i+1][1] = p[i][1]
		end
		if (p[i][1] > p[i+2][1]) then
			p[i+2][1] = p[i][1]
		end
		if (p[i+1][1] > p[i+3][1]) then
			p[i+1][1] = p[i+3][1]
		end
		if (p[i+2][1] > p[i+3][1]) then
			p[i+2][1] = p[i+3][1]
		end
	end
end

-------------------------------------------------------------------------------
-- 正規化
local pn = {}
pn[0] = {0,0}
for i=1,#p do
	pn[i] = {
		   (S+p[i][1])/(S*2),
		1-((S+p[i][2])/(S*2)) -- yは反転
	}
end

local pAtr = pA

for i = 1, (28 +1) do
	if (pAtr[i] == nil) then
		pAtr[i] = -1
	else
		pAtr[i] = pAtr[i] + S
	end
end


local function f()
	if (W==1) then
		require "マルチベジエ軌道".set(N, num, ACCURACY, B, S*2, pAtr)
	end
end
pcall(f)


--求めたい値yの計算---------------------------------------------------------------
local BezierX
-- 正規化時、アンカー毎にオフセット＆スケールで制御点だけにできそうです
if (B==2) then
	BezierX = function(t,x0,x1,x2)
		local k=(1-t)
		-- return (x1*2*t)*k + t*t
		return (x0*k + x1*2*t)*k + x2*t*t
	end
else
	BezierX = function(t,x0,x1,x2,x3)
		local k = 1-t
		-- return ((x1*k + x2*t)*3*t)*k + t*t*t
		return (x0*k*k + (x1*k + x2*t)*3*t)*k + x3*t*t*t
	end
end

-- 変化値をTimeにキャッシュするようにして.traでは線形補間に変更
local Time = {}
Time[0] = 0
Time[ACCURACY] = 1

for i = 1,ACCURACY-1 do
	local t = i/ACCURACY

	-- tと対応するカーブの始点kを探す
	local k = 0
	for j=0,#pn-B,B do
		if (t > pn[j][1]) and (t <= pn[j+B][1]) then
			k = j
		end
	end

	-- Bisection method
	local p3 = pn[k+3] or {} --Quadだとフィールドが無いので
	local t_min = 0
	local t_max = 1
	local th = (t_min + t_max)*0.5
	local x
	for j=0,12 do -- 8回程度で問題ない精度っぽい
		x = BezierX(th,pn[k][1],pn[k+1][1],pn[k+2][1],p3[1])
		if (t < x) then
			t_max = th
		else
			t_min = th
		end
		th = (t_min + t_max)*0.5
	end
	 Time[i] = BezierX(th,pn[k][2],pn[k+1][2],pn[k+2][2],p3[2])
end

-- マルチベジェ軌道.traに送る-----------------------------------------------------
if (W==1) then
	Bezier_flow[N] = Time
end

-- グラフ表示 ===================================================================
if not (hdn==1 and obj.getinfo("saving")==true) and (edt>=1) then
	if (edt==2) then
		SD = 0 -- グラフのモードはトラックバーで変更するようにした
	end
	pre = (pre or 1)
	if (pre < 0) then
		GRAD = 1
		pre = math.abs(pre)
	end
	local color = PALLETTE[pre]
	local col_bg = (color.BG or 0x0f0f0f)
	local col_write  = ({0x888888,0x00819c,0xe81e63})[W+2]
	local nzo = 1/math.max(1,zo) -- 拡大時にズームの逆数を使用

	
	local function length2(a,b)
		local l = math.sqrt((b[1]-a[1])^2 + (b[2]-a[2])^2)
		if l==0 then return 1e-08 end
		return l
	end

	local function norm2(a,b)
		local v = {b[1]-a[1], b[2]-a[2]}
		local l = 1 / math.sqrt(v[1]*v[1] + v[2]*v[2])
		return {v[1]*l, v[2]*l}
	end

	local function dot(a,b)
		return (a[1]*b[1] + a[2]+b[2])
	end

	local function drawline(p0,p1,w,alp,color)
		w,alp = (w or 1)*0.5,alp or 1
		obj.putpixel(0,0,(color or 0xfffff),1)
		local v = {p1[1]-p0[1],p1[2]-p0[2]}
		local l = math.sqrt(v[1]*v[1] + v[2]*v[2])
		local x,y = -v[2]/l*w,v[1]/l*w
		obj.drawpoly(
		p0[1]-x,p0[2]-y,0,
		p1[1]-x,p1[2]-y,0,
		p1[1]+x,p1[2]+y,0,
		p0[1]+x,p0[2]+y,0
		,0,0, 0,0, 0,0, 0,0,alp
		)
	end

	local function drawrect(w,h,x,y,alp,color)
		obj.putpixel(0,0,(color or 0xfffff),1)
		w = w*0.5
		h = h*0.5
		obj.drawpoly(-w+x,-h+y,0, w+x,-h+y,0, w+x,h+y,0,-w+x,h+y,0, 0,0, 0,0, 0,0, 0,0, alp or 1)
	end

	local BezierV
	if (B==2) then
		BezierV = function(t,p0,p1,p2) -- Quad_bezier
			local k = (1-t)
			return {
				(p0[1]*k + p1[1]*2*t)*k + p2[1]*t*t,
				(p0[2]*k + p1[2]*2*t)*k + p2[2]*t*t
			}
		end
	else
		BezierV = function(t,p0,p1,p2,p3) -- Cubic_bezier
			local k = (1-t)
			return {
				(p0[1]*k*k + (p1[1]*k + p2[1]*t)*3*t)*k + p3[1]*t*t*t,
				(p0[2]*k*k + (p1[2]*k + p2[2]*t)*3*t)*k + p3[2]*t*t*t
			}
		end
	end

	-- 背景
	-- obj.setoption("drawtarget","tempbuffer",1/zo*S*2+30, 1/zo*S*S_max*2+30)
	local SC = S-0.5
	obj.load("figure","四角形",0x232323,1/zo*S*2+30) --obj.effect()
	obj.draw(0,0,0,1,1)
	obj.load("figure","四角形",col_bg,1/zo*S*2) obj.effect()
	obj.draw(0,0,0,1,1)
	drawline(p[0],p[#p],1,0.3,0x888888)

	-- 枠
	drawrect(SC*2,1,0,-SC,0.5,col_write)
	drawrect(SC*2,1,0, SC,0.5,col_write)
	drawrect(1,SC*2,-SC,0,0.5,col_write)
	drawrect(1,SC*2, SC,0,0.5,col_write)

	if (SD==0) and  (W==0) and (Bezier_flow[N]) then
		obj.load("figure","四角形",0xffffff,2)
		local d = 1
		for i=0,#Bezier_flow[N]-d,d do
			local y =  S - S*2 * Bezier_flow[N][i]
			local x = -S + S*2 * i/#Bezier_flow[N]
			obj.draw(x, y, 0,nzo,0.08)
			drawline({x,y},{-S + S*2 * (i+d)/#Bezier_flow[N] ,S - S*2 * Bezier_flow[N][i+d]},0.5,0.08,0xffffff)
		end
	end

	-- メッセージ
	if (emp==0) then
		obj.setfont(FONT,50,0,Bezier_flow[N]==nil and 0xdaff00 or col_write)
		obj.load(N)
		obj.draw(SC-50*zo,SC-50*zo)
	end

	if (init) then
		obj.setfont(FONT,24)
		obj.load("<#fa2222>Initialize")
		local w,h = obj.getpixel()
		obj.draw(-h/2,-h,0,1,1,0,0,-45)
		Bezier_flow[N] = nil
		local function f()
			require "マルチベジエ軌道".remove(N)
		end
		pcall(f)
	end

	if (emp==1) then
		obj.setfont(FONT,24)
		obj.load("<#ff0048>delete all settings")
		local w,h = obj.getpixel()
		obj.draw(SC-(w+40)/2*zo,SC-20*zo)
		Bezier_flow = nil
		local function f()
			require "マルチベジエ軌道".reset()
		end
		pcall(f)
	elseif Bezier_flow[N]==nil then
		obj.setfont(FONT,20)
		obj.load("empty")
		local w,h = obj.getpixel()
		obj.draw(SC-(w+40)/2*zo,SC-20*zo)
	elseif (W==1) then
		obj.setfont(FONT,20,0,col_write)
		obj.load("write")
		local w,h = obj.getpixel()
		obj.draw(SC-(w+50)/2*zo,SC-20*zo)
	end


	if (SD==1) then --============================================================
		-- 簡易グラフ表示
		for i=0,#p-B,B do
			obj.load("figure","円",color[(i/B)%(#color)+1],6)
			local d = 1 / math.max(30,(length2(p[i],p[i+B])/5))
			for j=0,1,d do
				local v = BezierV(j, p[i],p[i+1],p[i+2],p[i+3])
				obj.draw(v[1],v[2],0,0.8*nzo,1.5)
			end
		end
	elseif (SD==0) then --========================================================
		-- ちょっと重いグラフ表示
		local function LinearTimeBezier(time,num,p0,p1,p2,p3,draw,floor)
			p3 = (p3 or p2)
			if (math.abs(num)<0.1) or (time<=0) or (length2(p0,p3)==1e-08) then
				return {[0]={p0[1],p0[2],t=0,rot=0},{p3[1],p3[2],t=0,rot=0}}
			end
			time = (time or 1)
			local P = {[0]=p0} -- 点の位置
			local L = {[0]=0}  -- 区間k長さ = L[k+1]-L[k]
			local n -- 最終的な描画数
			local fix = (floor and 0) or 1

			-- 各区間長さを配列化
			if (num > 0) then
				-- 描画数固定の場合
				for i=1,num do
					P[i] = BezierV(i/num,p0,p1,p2,p3)
					L[i] = L[i-1] + length2(P[i],P[i-1])
				end
				n = num
			elseif (num < 0) then
				-- numがマイナスの場合は描画間隔指定なので全体長さを元に描画数を再計算

				-- まずは直線距離から大雑把に描画数をきめて曲線の長さを計測
				num = math.abs(num)
				local N = math.floor(length2(p0,p3)/10/num) + 2
				for i=1,N do
					P[i] = BezierV(i/N,p0,p1,p2,p3)
					L[i] = L[i-1] + length2(P[i],P[i-1])
				end

				-- 曲線の長さから描画数を決定して再計算
				N = math.ceil( L[#L] / num )
				P = {[0]=p0}
				L = {[0]=0}
				for i=1,N do
					P[i] = BezierV(i/N,p0,p1,p2,p3)
					L[i] = L[i-1] + length2(P[i],P[i-1])
				end
				n = L[#L] / num -- nは整数化しない(ぬるぬる移動する)
			end

			if (floor) then
				n = math.floor(n)
			end

			-- 区間長さを全体長さで割って正規化すると時間tと比較できる
			for i=1,#L do
				L[i] = L[i] / L[#L]
			end

			local ret = {} -- 戻り値
			local k = 0    -- 区間番号

			-- 補正の実行
			for i=0,n do
				local t = 1/n*i -- 時間t

				-- tがどの区間(L[k]~L[k+1])にいるか調べる
				for j=k,#L-1 do
					if (L[j]<=t and t<=L[j+1]) then
						-- 見つかったらkを更新
						k = j
						break
					end
				end

				-- 時間tが区間L[k]〜L[k+1]のどのあたりかのratio
				local ratio = (t-L[k]) / math.max(L[k+1]-L[k], 1e-08 )

				-- 次の点(k+1)と線形補間
				local v = {
					P[k][1] + (P[k+1][1] - P[k][1]) * ratio,
					P[k][2] + (P[k+1][2] - P[k][2]) * ratio,
					-- P[k][3] + (P[k+1][3]-P[k][3]) * ratio, -- z
					-- t = L[k] + (L[k+1]-L[k]) * ratio, -- time
					rot = math.deg(math.atan2(P[k+1][2]-P[k][2],P[k+1][1]-P[k][1])) + 90
				}
				ret[i+1] = v
			end

			-- 最後の点p3を追加（nを整数化していない場合）
			if not (floor) then
				p3.rot = math.deg(math.atan2(p3[2]-ret[#ret][2],p3[1]-ret[#ret][1])) + 90
				table.insert(ret,p3)
			end

			if (draw==1) then
				for i=1,#ret do
					obj.draw(ret[i][1],ret[i][2],0 ,nzo,1,0,0,ret[i].rot or 0)
				end
			elseif type(draw)=="string" then
				local str = split(draw,",")
				for i=1,#ret do
					obj.load(str[(#ret-i)%#str+1])
					obj.draw(ret[i][1],ret[i][2],0 ,1,1,0,0,ret[i].rot or 0)
				end
			end

			return ret
		end

		-- グリッド
		local n = math.max(num,2)
		for i=1,n-1 do
			local j = (S - S/n * i*2) + 0.5
			drawrect(SC*2,1,0,j,0.04,0xffffff)
			drawrect(1,SC*2,j,0,0.04,0xffffff)
		end

		-- アンカーポイント・ライン(X)
		for i=B,#p-B,B do
				drawrect(3,2,p[i][1],S-1,2,col_write)
				drawrect(3,2,p[i][1],-S+1,2,col_write)
				drawline({p[i][1],p[i][2]+5},{p[i][1],S},0.4,1,col_write)
		end

		-- グラフ
		for i=0,#p-B,B do
			local col = color[(i/B)%(#color)+1]
			if (W==1) then
				obj.load("figure","四角形",col,4,100,-0.5)
				local v = LinearTimeBezier(1,-6*1*math.min(1,zo),p[i],p[i+1],p[i+2],p[i+3],(1-GRAD),false)
				if (GRAD)==1 then
					local n = #v-(B==2 and 2 or 1)
					for j=1,n do
						local c = col_lerp((j/n), color[(i/B)%(#color)+1],color[((i+B)/B)%(#color)+1] )
						obj.load("figure","四角形",c,4,100,-0.5)
						--drawline(v[j],v[j+1],1,1,c)
						obj.draw(v[j][1],v[j][2],0, nzo,1, 0,0, v[j].rot)
					end
				end
			else
				obj.load("figure","四角形",col,4,100,0.5)
				local v = LinearTimeBezier(1,-6*1*math.min(1,zo),p[i],p[i+1],p[i+2],p[i+3],(1-GRAD),false)
				if (GRAD)==1 then
					local n = #v-(B==2 and 2 or 1)
					for j=1,n do
						local c = col_lerp((j/n), color[(i/B)%(#color)+1],color[((i+B)/B)%(#color)+1] )
						obj.load("figure","四角形",c,4,100,0.5)
						--drawline(v[j],v[j+2],1,1,c)
						obj.draw(v[j][1],v[j][2],0, nzo,1, 0,0, v[j].rot)
					end
				end
			end
		end

	end 	--======================================================================


	-- ハンドル
	for i=0,#p-B,B do
		local col = color[(i/B)%(#color)+1]
		if (B==2) then
			drawline(p[i],p[i+1]  ,1,0.6,col)
			drawline(p[i+1],p[i+2],1,0.6,col)
			obj.load("figure","四角形",0x555563,8)
			obj.draw(p[i+1][1],p[i+1][2],0,nzo,1.5)
			obj.load("figure","四角形",col,6)
			obj.draw(p[i+1][1],p[i+1][2],0,nzo)
		else
			local D0=0
			drawline(p[i],p[i+1]  ,1,0.8,col)
			drawline(p[i+2],p[i+3],1,0.8,col)
			if i<#p-B then
			 D0 = dot(norm2(p[i+3],p[i+2]),norm2(p[i+4],p[i+3]))
		 end
			--obj.load(string.format("%.3f",D0))
			obj.load("figure","四角形",0x080808,8)
			obj.draw(p[i+2][1],p[i+2][2],0,nzo,1.5)
			obj.draw(p[i+1][1],p[i+1][2],0,nzo,1.5)
			obj.load("figure","四角形",col,6)
			obj.draw(p[i+2][1],p[i+2][2],0,nzo)
			obj.draw(p[i+1][1],p[i+1][2],0,nzo)
		end
	end

	-- アンカーポイント
	for i=B,#p-B,B do
		if math.floor(p[i][2])==S or math.floor(p[i][2])==-S then
			obj.load("figure","円",0xcd2d2d,16)
		else
			obj.load("figure","円",0xf8f8f8,14)
		end
		obj.draw(p[i][1],p[i][2],0,0.8*nzo,1.8,0,0,60)
	end
	for i=B,#p-B,B do
		obj.load("figure","円",(color[(i/B)%(#color)+1]),10)
		obj.draw(p[i][1],p[i][2],0,0.8*nzo,1.8)
	end

	-- 始点:終点
	obj.load("figure","四角形",col_write,8)
	obj.draw(p[0][1],p[0][2],0,nzo,1)
	obj.draw(p[#p][1],p[#p][2],0,nzo,1)

	-- 現在の位置
	if (obj.totalframe~=0) then --オブジェクトの長さが1フレームだとダメなので
		local t = obj.time / obj.totaltime
		local i,time = math.modf(t*(#Time))
		local r = ((Time[i+1] or 1) - Time[i]) * time + Time[i]
		local x = -S + S*2 * t
		local y =  S - S*2 * r
		obj.load("figure","円",0xff9914,20)
		obj.draw(x,y,0,0.5*nzo)
		if SD==0 then
			drawrect(1,S*2,x,0,0.4,0xff9914)
			drawrect(S*2,1,0,math.max(-S,math.min(S,y)),0.4,0xff9914)
		end
	end
end
-- obj.copybuffer("obj","tmp")
