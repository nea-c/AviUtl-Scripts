--[[
	ﾌｨﾙﾀﾓｰﾄﾞは一枚にまとめず下につけたフィルター効果が個別に掛かるようになります。
	カメラ制御下では重なって表示されておかしなことになります。
	
	イージングはマイナスだとマルチベジェ軌道を利用できます。
]]
--track0:進捗,-100,100,0,0.01
--track1:ランダム度,0,100,0
--track2:サイズ,-200,1000,0,1
--track3:スライス数,2,20,5,1
--dialog:最大回転角,local rotmax=180*2;サイズランダム/chk,local s_rand=1;seed,local seed=2018;ズレ[0/100],local delay=0;└ Order[0/4],local order=0;Easing[0/41],local ease=0;中心,pos={0,0};ﾌｨﾙﾀﾓｰﾄﾞ/chk,local is_fx=1;
--check0:回転交互(ﾗﾝﾀﾞﾑ無効),0
--回転偏り[±100],local bias=0;
local rot   = obj.track0 * 0.01
local rnd   = obj.track1 * 0.01
local size  = obj.track2
local num   = obj.track3
local delay = delay * 0.01
local sign  = (rot<0 and -1) or 1
local alpha = (is_fx==1 and 1) or 2

obj.setanchor("pos",1)
pos = pos or {0,0}
local x,y = pos[1],pos[2]
local w,h = obj.getpixel()
local s = math.min(w,h) -- (w*w+h*h)^0.5

local function clamp(x)
	return (x<=0 and 0) or (x>=1 and 1) or x
end

local function lerp(t,a,b)
	return t * (b-a) + a
end

local function Sequence(t,delay,i,num)
	if (t < 0) then t,i = -t,num-i end
		return clamp( t*(1+delay*num ) - delay*i)
end

local function Shuffle_tbl(tbl,seed)
	local count = #tbl
	math.randomseed(seed or 0)
	local j
	for i = count,2,-1 do
		j = math.random(i)
		tbl[i], tbl[j] = tbl[j], tbl[i]
	end
	return tbl
end

local function Easing(x) return x end
if (ease) and (ease>0) then
	local E = require("easing")
	local easelist = {
		"linear",                                               -- 1
		"inSine",   "outSine",   "inOutSine",   "outInSine",    -- 2,3,4,5
		"inQuad",   "outQuad",   "inOutQuad",   "outInQuad",    -- 6,7,8,9
		"inCubic",  "outCubic",  "inOutCubic",  "outInCubic",   -- 10,11,12,13
		"inQuart",  "outQuart",  "inOutQuart",  "outInQuart",   -- 14,15,16,17
		"inQuint",  "outQuint",  "inOutQuint",  "outInQuint",   -- 18,19,20,21
		"inExpo",   "outExpo",   "inOutExpo",   "outInExpo",    -- 22,23,24,25
		"inCirc",   "outCirc",   "inOutCirc",   "outInCirc",    -- 26,27,28,29
		"inElastic","outElastic","inOutElastic","outInElastic", -- 30,31,32,33
		"inBack",   "outBack",   "inOutBack",   "outInBack",    -- 34,35,36,37
		"inBounce", "outBounce", "inOutBounce", "outInBounce"   -- 28,39,40,41
	}
	Easing = function(x)
		return E[easelist[ease]](x,0,1,1)
	end
end

if (ease and ease < 0) then
	local function f()
		return require "マルチベジエ軌道"
	end
	local a, MBLua = pcall(f)
    if (a) then
        Easing = function(x)
            local Time = MBLua.calc(MBLua.get(-ease))
            if not (Time) then
                return x
            end
            local i, t = math.modf(x * #Time)
            return ((Time[i + 1] or 1) - Time[i]) * t + Time[i]
        end
    elseif (Bezier_flow.time) then
	Easing = function(x)
		return Bezier_flow.time(-ease,x)
	end
end
end

local Order = ({
	  [0] = function(i) return i end,
		function(i) return num-1-i end,
		function(i)
			return math.abs(num-1 - i*2)
		end,
		function(i)
			return num - math.abs(num-1 - i*2)
		end,
		function(i,seed)
			local id = {}
			for i=1,num do id[i] = i-1 end
			return Shuffle_tbl(id,seed)[i+1]
		end
})[order%5]

obj.effect("マスク","サイズ",s + size,"マスクの反転",0,"type",1)
obj.copybuffer("cache:org","obj")
if (is_fx==0) then
	obj.setoption("dst","tmp",w,h)
	obj.setoption("blend",0)
end

if (s_rand==1) then
	for i = 0,num - 1 do
		obj.copybuffer("obj","cache:org")
		obj.effect("マスク","サイズ",s + size,"マスクの反転",0,"type",1,"X",x,"Y",y)
		if (is_fx==1) then
			obj.effect()
		end
		s = s - obj.rand(10,s/num*2.5,seed,i)
		local rotate = obj.rand(-1000,1000,seed,i)*0.001 * rotmax
		rotate = lerp(rnd, rotmax, rotate)
		rotate = obj.check0 and (i%2-0.5)*2*rotmax or rotate
		local j = Easing( Sequence(rot,delay,Order(i,seed),num-1) )
		if (s <= 0) then break end
		-- obj.effect("色調補正","色相",obj.rand(0,360,i,1)*j)
		obj.draw(0,0,0,1,alpha,0,0,rotate* j *sign)
	end
else
	for i = 0,num - 1 do
		obj.copybuffer("obj","cache:org")
		obj.effect("マスク","サイズ",(s - (s/(num-1) * i)) + size,"マスクの反転",0,"type",1,"X",x,"Y",y)
		if (is_fx==1) then
			obj.effect()
		end
		local rotate = obj.rand(-100,100,seed,i)*0.01 * rotmax
		rotate = lerp(rnd, rotmax, rotate)
		rotate = obj.check0 and (i%2-0.5)*2*rotmax or rotate
		local j = Easing( Sequence(rot,delay,Order(i,seed),num-1) )
		if (s <= 0) then break end
		-- obj.effect("色調補正","色相",obj.rand(0,360,i,1)*j)
		obj.draw(0,0,0,1,alpha,0,0,rotate* j *sign)
	end
end

if (is_fx==0) then
	obj.copybuffer("obj","tmp")
end