--/////////////////////////////////////////////////////////////////////////////
@TA-Normal
--/////////////////////////////////////////////////////////////////////////////
--track0:in/out,-100,100,0,0.01
--track1:ズレ,0,100,10,0.01
--track2:--,0,100,0
--track3:random,-2000,2000,0
--dialog:easing,local ease={0, 0};座標 in,local pos={0, -100, 0};└ out,local poso={0, 100, 0};回転 in,local rot={0, 0, 0};└ out,local roto={0, 0, 0};フェード/chk,local fd=0;拡大率,local zm=0;ぼかし,local bl=0;order[0/4],local ord={0,0};seed,local sd={0,0}
--check0:自動,0;
local function clamp(x) return (x<=0 and 0) or (x>=1 and 1) or x end
local function lerp(t,a,b) return t*(b-a) + a end
local function linear(t,a,b,A,B) return clamp((t-a)/(b-a)) * (B-A) + A end
local function smooth(x) return x*x*(3-2*x) end
local function sequence(t,delay,index,num)
	if (t < 0) then t,index = -t,num-index end
	return clamp( t*(1+delay*num) - delay*index)
end

local function shuffle_tbl(tbl,seed)
	local count = #tbl
	math.randomseed(seed or 0)
	local j
	for i = count,2,-1 do
		j = math.random(i)
		tbl[i], tbl[j] = tbl[j], tbl[i]
	end
	return tbl
end

local function TA_spd(g)
	g=g or 0
	local l,i,t = obj.layer,obj.index,obj.time
	local rate = 1/obj.framerate
	local k = {obj.x*g+obj.ox,obj.y*g+obj.oy,0,obj.rz}
	SPD = SPD or {}
	SPD[l] = SPD[l] or {t=0}
	if SPD[l][i]==nil then SPD[l][i] = k end
	local s = SPD[l][i][3]
	local r = SPD[l][i][4]
	local ending = (obj.time==obj.totaltime) and (SPD[l].t <= t)
	if ending or (SPD[l].t < t) then
		local x,y = k[1]-SPD[l][i][1] ,k[2]-SPD[l][i][2]
		s = math.sqrt(x*x + y*y)
		s = math.log(s/10+1,10)
		if (s > 0) then
			r = math.deg(math.atan2(y,x)) + 90
		end
		SPD[l][i] = {k[1],k[2],s,r}
		if (i==obj.num-1) then SPD[l].t = t end
	elseif (SPD[l].t > t) then
		SPD[l][i] = k
		if (i==obj.num-1) then SPD[l].t = t end
	end
	return s,r
end

local Order = {
	  [0] = function()
			return obj.index
		end,
		function()
			return (obj.num-1)-obj.index
		end,
		function()
			return math.abs((obj.num) - obj.index*2 - 1)
		end,
		function()
			return obj.num - math.abs((obj.num) - obj.index*2 - 1)
		end,
		function(seed)
			local id = {}
			for i=1,obj.num do
				id[i] = i-1
			end
			return shuffle_tbl(id,seed)[obj.index+1]
		end
}

local colorize = {0xd5e6ca,0xa10a31,0x5ba6a5,0x170f1f,0xdfdfd9}

if not tostring(ease):find("table:") then ease = {ease,ease} end
local easein = ease[1]
local easeout = (ease[2] or ease[1])

local function easing(x) return x*x*(3-2*x) end
if (easein>0 or easeout>0) then
	local E = require("easing")
	local easelist = {
		"linear",                                               -- 1
		"inSine",   "outSine",   "inOutSine",   "outInSine",    -- 2,3,4,5
		"inQuad",   "outQuad",   "inOutQuad",   "outInQuad",    -- 6,7,8,9
		"inCubic",  "outCubic",  "inOutCubic",  "outInCubic",   -- 10,11,12,13
		"inQuart",  "outQuart",  "inOutQuart",  "outInQuart",   -- 14,15,16,17
		"inQuint",  "outQuint",  "inOutQuint",  "outInQuint",   -- 18,19,20,21
		"inExpo",   "outExpo",   "inOutExpo",   "outInExpo",    -- 22,23,24,25
		"inCirc",   "outCirc",   "inOutCirc",   "outInCirc",    -- 26,27,28,29
		"inElastic","outElastic","inOutElastic","outInElastic", -- 30,31,32,33
		"inBack",   "outBack",   "inOutBack",   "outInBack",    -- 34,35,36,37
		"inBounce", "outBounce", "inOutBounce", "outInBounce"   -- 28,39,40,41
	}
	easing = function(x,n)
		return E[easelist[n]](x,0,1,1)
	end
end

local function multi_bezier(x) return x*x*(3-2*x) end

local function f()
      return require"マルチベジエ軌道"
end
local a,MBLua = pcall(f)
if (a) then
      multi_bezier = function(x, n)
            local Time = MBLua.calc(MBLua.get(-n))
            if not (Time) then return x end
		local i,t = math.modf(x * #Time)
		return ((Time[i+1] or 1) - Time[i]) * t + Time[i]
	end
elseif (Bezier_flow and Bezier_flow.time) then
	multi_bezier = function(x,n)
		return Bezier_flow.time(-n,x)
	end
end

if not tostring(pos):find("table:") then pos = {pos,0,0} end
if not tostring(rot):find("table:") then rot = {rot,0,0} end
if not tostring(poso):find("table:") then poso = {poso,0,0} end
if not tostring(roto):find("table:") then roto = {roto,0,0} end
if not tostring(ord):find("table:") then ord = {ord,ord} end
if not tostring(sd):find("table:") then sd = {sd,sd} end
if not tostring(zm):find("table:") then zm = {zm,zm} end

local default = {0,0,0}
setmetatable(pos ,{__index=default})
setmetatable(rot ,{__index=default})
setmetatable(poso,{__index=pos})
setmetatable(roto,{__index=rot})
setmetatable(ord ,{__index=default})

local prog = obj.track0*0.01
local st = (prog<0 and prog) or 0
local ed = (prog>0 and prog) or 0
local delay = obj.track1*0.01
local easenum = math.floor(obj.track2)
local rand_am = obj.track3*2
math.randomseed((seed or 0))

-- チェック時はTAと似た動作
if (obj.check0) then
	local pt = math.abs(obj.track0/10)
	st = clamp(obj.time / pt)
	ed = clamp((obj.time-(obj.totaltime-pt)) / pt)
	if (prog<0) then
		st,ed = -st,ed
	end
end

local vs,ve = 0,0
if (st<=1) then
	if (obj.check0) then
		vs = sequence(st,delay,Order[ord[1]%5](sd[1]),obj.num-1)
		if (easein>0) then
			vs = 1-easing(vs,easein)
		elseif (easein<0) then
			vs = 1-multi_bezier(vs,easein)
		else
			vs = 1-(vs*vs*(3-2*vs))
		end
	else
		vs = sequence(st,delay,Order[ord[1]%5](sd[1]),obj.num-1)
		if (easein>0) then
			vs = 1-easing(1-vs,easein)
		elseif (easein<0) then
			vs = 1-multi_bezier(1-vs,easein)
		end
	end
end

if (ed>0) then
	ed = -(1-ed)
	ve = sequence(ed,delay,Order[ord[2]%5](sd[2] or sd[1]),obj.num-1)
	if (easeout>0) then
		ve = 1-easing(ve,easeout)
	elseif (easeout<0) then
		ve = 1-multi_bezier(ve,easeout)
	else
		ve = 1-ve
	end
end

local rnd = {obj.rand(-100,100,sd[1]+1,obj.index+1),obj.rand(-100,100,sd[1]+10,obj.index+1),obj.rand(-100,100,sd[1]+100,obj.index+1)}
local va = 1-(1-vs)*(1-ve)
obj.ox = obj.ox + pos[1] * vs + poso[1] * ve + rnd[1]*rand_am/100 * va
obj.oy = obj.oy + pos[2] * vs + poso[2] * ve + rnd[2]*rand_am/100 * va
obj.oz = obj.oz + pos[3] * vs + poso[3] * ve + rnd[3]*rand_am/100 * va
obj.rx = obj.rx + rot[1] * vs + roto[1] * ve
obj.ry = obj.ry + rot[2] * vs + roto[2] * ve
obj.rz = obj.rz + rot[3] * vs + roto[3] * ve
obj.zoom = obj.zoom + zm[1]*0.01 * va * vs + zm[2]*0.01 * ve
obj.alpha = obj.alpha * (fd==1 and (1-math.abs(va)) or 1)


if (bl>0) and (va>0) then
	obj.effect("ぼかし","範囲",bl*va)
elseif (bl<0) then
	local s,r = TA_spd(1)
	local va0 = 1
	obj.effect("色ずれ","type",4,"ずれ幅",-bl*0.75*va0,"強さ",s*100,"角度",r)
	obj.effect("方向ブラー","範囲",-bl*s*va0,"角度",r)
end



-- 座標情報をPOSで垂れ流し
if (obj.index==0) then
	POS = {}
	POS.v = {}
	-- 文字がスペースや特定の記号だと処理が飛ぶフォントがあり、
	-- テーブルにnilが入るためシーケンスでなくなってしまう(=indexが連続していない)
	-- なので適当な変数を用意してobj.indexの代わりに使う
	i_index = 0
end
if (obj.ox) then
	-- obj.indexより大きくならないようにする(スクリプト複数付けた場合の対策)
	i_index = (i_index <= obj.index and (i_index+1)) or i_index
	POS[i_index*3-2] = (obj.x+obj.ox)
	POS[i_index*3-1] = (obj.y+obj.oy)
	POS[i_index*3  ] = (obj.z+obj.oz)
	POS.v[i_index] = {obj.x+obj.ox, obj.y+obj.oy, obj.z+obj.oz}
end

-- 結果を垂れ流し
TA_N = va

--/////////////////////////////////////////////////////////////////////////////
@TA-Arrange
--/////////////////////////////////////////////////////////////////////////////
--track0:prog,0,300,0,0.01
--track1:dealy,0,100,0,0.01
--track2:space,0,3000,100
--track3:radius,0,3000,100
--dialog:easing,local ease=0;向く/chk,local at=0;改行位置,local nline=0;円数,local cnum=1;Order[0/4],local order=0;seed,local seed=0;全体を回転/chk,local rot=0;
local function clamp(x) return (x<=0 and 0) or (x>=1 and 1) or x end
local function lerp(t,a,b) return t*(b-a)+a end
local function easing(x) return x*x*(3-2*x) end
if (ease) and (ease>0) then
	local E = require("easing")
	local easelist = {
		"linear",                                               -- 1
		"inSine",   "outSine",   "inOutSine",   "outInSine",    -- 2,3,4,5
		"inQuad",   "outQuad",   "inOutQuad",   "outInQuad",    -- 6,7,8,9
		"inCubic",  "outCubic",  "inOutCubic",  "outInCubic",   -- 10,11,12,13
		"inQuart",  "outQuart",  "inOutQuart",  "outInQuart",   -- 14,15,16,17
		"inQuint",  "outQuint",  "inOutQuint",  "outInQuint",   -- 18,19,20,21
		"inExpo",   "outExpo",   "inOutExpo",   "outInExpo",    -- 22,23,24,25
		"inCirc",   "outCirc",   "inOutCirc",   "outInCirc",    -- 26,27,28,29
		"inElastic","outElastic","inOutElastic","outInElastic", -- 30,31,32,33
		"inBack",   "outBack",   "inOutBack",   "outInBack",    -- 34,35,36,37
		"inBounce", "outBounce", "inOutBounce", "outInBounce"   -- 28,39,40,41
	}
	easing = function(x)
		return E[easelist[ease]](x,0,1,1)
	end
end

if (ease and ease<0) then
	local function f()
		return require"マルチベジエ軌道"
	end
	local a,MBLua = pcall(f)
	if (a) then
		easing = function(x)
		  	local Time = MBLua.calc(MBLua.get(-ease))
		  	if not (Time) then return x end
	  		local i,t = math.modf(x * #Time)
	  		return ((Time[i+1] or 1) - Time[i]) * t + Time[i]
  		end
	elseif (Bezier_flow.time) then
		easing = function(x)
			return Bezier_flow.time(-ease,x)
		end
	end
end

local function sequence(t,delay,index,num)
	if (t < 0) then t,index = -t,num-index end
	return clamp( t*(1+delay*num) - delay*index)
end

local function shuffle_tbl(tbl,seed)
	local count = #tbl
	math.randomseed(seed or 0)
	local j
	for i = count,2,-1 do
		j = math.random(i)
		tbl[i], tbl[j] = tbl[j], tbl[i]
	end
	return tbl
end

if not (Setmtx) then
	local function mtx(ang)
		local rad = math.pi/180
		ang = ang or {obj.rx,obj.ry,obj.rz}
		local cosx,sinx = math.cos(ang[1]*rad),math.sin(ang[1]*rad)
		local cosy,siny = math.cos(ang[2]*rad),math.sin(ang[2]*rad)
		local cosz,sinz = math.cos(ang[3]*rad),math.sin(ang[3]*rad)
		local function f(v)
			v[1],v[2] = (v[1]*cosz - v[2]*sinz),(v[1]*sinz + v[2]*cosz) -- z軸
			v[1],v[3] = (v[3]*siny + v[1]*cosy),(v[3]*cosy - v[1]*siny) -- y軸
			v[2],v[3] = (v[2]*cosx - v[3]*sinx),(v[2]*sinx + v[3]*cosx) -- x軸
			return v
		end
		return f
	end
	Setmtx = mtx
end
local Rotate = Setmtx()

local prog   = obj.track0*0.01
local delay  = obj.track1*0.01
local space  = obj.track2
local radius = obj.track3

local ox,oy,oz,rx,ry,rz = obj.ox,obj.oy,obj.oz,obj.rx,obj.ry,obj.rz
local Order = ({
	  [0] = function() return obj.index end,
		function() return obj.num-1-obj.index end,
		function()
			return math.abs((obj.num) - obj.index*2 - 1)
		end,
		function()
				return obj.num - math.abs((obj.num) - obj.index*2 - 1)
		end,
		function(seed)
			local id = {}
			for i=1,obj.num do id[i] = i-1 end
			return shuffle_tbl(id,seed)[obj.index+1]
		end
})[order%5]

local index = Order(seed or 1)
local ax,ay,t

if (prog<2) then----------------------------------------------------------------
	-- グリッド
	if (nline==0 or nline==nil) then
		local nl = math.floor(math.sqrt(obj.num))
		ax = (obj.index%nl) * space - (nl-1)*space*0.5
		ay = math.floor(obj.index/nl)*space - (nl-1)*space*0.5
	else
		local nl = nline
		ax = (obj.index%nl) * space - (nl-1)*space*0.5
		ay = math.floor(obj.index/nl)*space - (obj.num/nl)*space*0.5
	end

	t = sequence(clamp(prog),delay,index,obj.num-1)
	t = easing(t)
	obj.ox = lerp(t,obj.ox,ax)
	obj.oy = lerp(t,obj.oy,ay)
end

if (prog>1) then----------------------------------------------------------------
	-- 円形xy
	t = sequence(clamp(prog-1),delay,index,obj.num-1)
	t = easing(t)
	local r = math.pi*2/obj.num * obj.index*cnum
	local cosr = math.cos(r)
	local sinr = math.sin(r)
	ax = (cosr * radius) + (cosr * space) * math.floor(obj.index*cnum/obj.num)
	ay = (sinr * radius) + (sinr * space) * math.floor(obj.index*cnum/obj.num)
	obj.ox = lerp(t,obj.ox,ax)
	obj.oy = lerp(t,obj.oy,ay)
	obj.rz = lerp(t,obj.rz,obj.rz*(1-at) + (360/obj.num*obj.index*cnum+90+rz)%360 * at )
end

if (prog>2) then----------------------------------------------------------------
	--円形xz
	t = sequence(clamp(prog-2),delay,index,obj.num-1)
	t = easing(t)
	obj.oy = lerp(t,obj.oy,0)
	obj.oz = lerp(t,obj.oz,ay)
	obj.ry = lerp(t,obj.ry, ry*(1-at) - (360/obj.num*obj.index*cnum+90+rz)%360 * at )
	obj.rz = lerp(t,obj.rz,rz)
end

if rot==1 then
	obj.ox,obj.oy,obj.oz = unpack(Rotate({obj.ox,obj.oy,obj.oz}))
end

-- 座標情報をPOSで垂れ流し
if (obj.index==0) then
	POS = {}
	POS.v = {}
	i_index = 0
end
if (obj.ox) then
	i_index = (i_index <= obj.index and (i_index+1)) or i_index
	POS[i_index*3-2] = (obj.x+obj.ox)
	POS[i_index*3-1] = (obj.y+obj.oy)
	POS[i_index*3  ] = (obj.z+obj.oz)
	POS.v[i_index] = {obj.x+obj.ox, obj.y+obj.oy, obj.z+obj.oz}
end

--/////////////////////////////////////////////////////////////////////////////
@TA-Align to Bezier
--/////////////////////////////////////////////////////////////////////////////
--track0:offset,-1000,1000,0,0.01
--track1:回転,-180,180,0,90
--track2:--,0,1,1,1
--track3:適用度,0,100,100,0.01
--dialog:向く/chk,local fix=1;適用ズレ%,local delay=0;order[0/4],local order=0;ｱﾝｶｰ,pos={-200,200,0,-100,0,0,100,0,0,200,-200,0}
--check0:Quad⇔Cubic,1

LP2 = LP2 or function (...)
	local m = {...}
	local r = {}
	local g = obj.getvalue
	for i=1,#m do
		if g("layer"..m[i]..".x") then
			r[#r+1] = g("layer"..m[i]..".x")-obj.x
			r[#r+1] = g("layer"..m[i]..".y")-obj.y
		end
	end
	return r
end

LP3 = LP3 or function (...)
	local m = {...}
	local r = {}
	local g = obj.getvalue
	for i=1,#m do
		if g("layer"..m[i]..".x") then
			r[#r+1] = g("layer"..m[i]..".x")-obj.x
			r[#r+1] = g("layer"..m[i]..".y")-obj.y
			r[#r+1] = g("layer"..m[i]..".z")-obj.z
		end
	end
	return r
end

local function clamp(t) return (t<=0 and 0) or (t>=1 and 1) or (t) end
local function lerp(t, a, b) return t * (b-a) + a end
local function remap(t, t0, t1, v0, v1) return clamp((t-t0)/(t1-t0)) * (v1-v0) + v0 end
local function norm(t, t0, t1) return clamp((t-t0)/(t1-t0)) end
local function smooth_step(t) return t*t*(3-2*t) end
local function sequence(t,delay,i,imax) return clamp( t*(1+delay*imax ) - delay*i) end

if (obj.index==0) then

	local function quad_bezier(t,p0,p1,p2)
		local k = (1-t)
		return {
			(p0[1]*k + p1[1]*2*t)*k + p2[1]*(t*t),
			(p0[2]*k + p1[2]*2*t)*k + p2[2]*(t*t),
			(p0[3]*k + p1[3]*2*t)*k + p2[3]*(t*t)
		}
	end

	local function cubic_bezier(t,p0,p1,p2,p3)
		local k = (1-t)
		local tq = t*t*t
		return {
			(p0[1]*k*k + (p1[1]*k + p2[1]*t)*3*t)*k + p3[1]*tq,
			(p0[2]*k*k + (p1[2]*k + p2[2]*t)*3*t)*k + p3[2]*tq,
			(p0[3]*k*k + (p1[3]*k + p2[3]*t)*3*t)*k + p3[3]*tq
		}
	end

	local function length2(a,b)
		return math.sqrt((b[1]-a[1])^2 + (b[2]-a[2])^2 + (b[3]-a[3])^2)
	end

	local DEG = 180/math.pi

	if not (linear_time_bezier) then

		function linear_time_bezier(num,point)
			local p0,p1,p2,p3
			local bezier
			if (#point == 3) then
				p0,p1,p2 = unpack(point)
				bezier = quad_bezier
			else
				p0,p1,p2,p3 = unpack(point)
				bezier = cubic_bezier
			end
			local P = {[0]=p0}
			local L = {[0]=0}

			if (num<0) then
				for i=1,20 do
					P[i] = bezier(i/(-num),p0,p1,p2,p3)
					L[i] = L[i-1] + length2(P[i],P[i-1])
				end
				num = L[#L] / -num
			end

			for i=1,num do
				P[i] = bezier(i/(num),p0,p1,p2,p3)
				L[i] = L[i-1] + length2(P[i],P[i-1])
			end
			local ret = {len = L[#L]}

			for i=1,#L do
				L[i] = L[i] / L[#L]
			end

			local x,y,z = p0[1],p0[2],p0[3]
			ret[0] = {x,y,z,rz = math.atan2(P[1][2]-y,P[1][1]-x) * DEG }
			local k = 0
			for i=1,num do
				local t = i/num
				for j=k,#L do
					if (L[j]<=t and t<=L[j+1]) then
						k = j
						break
					end
				end
				local ratio = (t - L[k]) / math.max(L[k+1]-L[k],1e-08)
				-- t = L[k] + (L[k+1]-L[k]) * ratio
				local nx = P[k][1] + (P[k+1][1] - P[k][1]) * ratio
				local ny = P[k][2] + (P[k+1][2] - P[k][2]) * ratio
				local nz = P[k][3] + (P[k+1][3] - P[k][3]) * ratio
				local rz = math.atan2(ny-y,nx-x) * DEG
				ret[i] = {nx,ny,nz,rz=rz}
				x,y,z = nx,ny,nz
			end
			return ret
		end

	end

	obj.setanchor("pos",(obj.check0 and 4 or 3),"xyz","line")

	-- -- bezier_v_point をグローバルで。複数付けられないが軽い
	-- local cp = {}
	-- for i=1,#pos/3 do
	-- 	cp[i] = {pos[i*3-2],pos[i*3-1],pos[i*3]}
	-- end
	-- bezier_v_point = linear_time_bezier(obj.num, cp,0)

end

-- bezier_v_point をローカルで。複数付けられるが重い
local cp = {}
for i=1,#pos/3 do
	cp[i] = {pos[i*3-2],pos[i*3-1],pos[i*3]}
end

local n     = obj.num
local index = obj.index
if (obj.num < 20) then
	n = 20
	index = obj.index/obj.num * n
end
local bezier_v_point = linear_time_bezier(n, cp)

local offset = obj.track0*0.01
local rot    = obj.track1
local align  = obj.track3*0.01

local k,t = math.modf(index + (offset*n)%n)
local ox = lerp(t, bezier_v_point[k%n][1], bezier_v_point[k%n+1][1])
local oy = lerp(t, bezier_v_point[k%n][2], bezier_v_point[k%n+1][2])
local oz = lerp(t, bezier_v_point[k%n][3], bezier_v_point[k%n+1][3])
local rz = lerp(t, bezier_v_point[k%n].rz, bezier_v_point[k%n+1].rz)
rz = (obj.rz+rot)*(1-fix) + (rz+rot)*fix

local id = obj.index
if (order==1) then
	id = obj.num-1-obj.index
elseif (order==2) then
	id = math.abs((obj.num) - obj.index*2 - 1)
elseif (order==3) then
	id = obj.num - math.abs((obj.num) - obj.index*2 - 1)
elseif (order>3) then
	local idx = {}
	for i=1,obj.num do idx[i] = i-1 end
	math.randomseed(order)
	local j
	for i = #idx,2,-1 do
		local j = math.random(i)
		idx[i], idx[j] = idx[j], idx[i]
	end
	id = idx[obj.index+1]
end

align = sequence(align, clamp(delay*0.01),id,n-1)
align = smooth_step(align)
obj.ox = lerp(align, obj.ox, ox)
obj.oy = lerp(align, obj.oy, oy)
obj.oz = lerp(align, obj.oz, oz)
obj.rz = lerp(align, obj.rz, rz)

-- 座標情報をPOSで垂れ流し
if (obj.index==0) then
	POS = {}
	POS.v = {}
	i_index = 0
end
if (obj.ox) then
	i_index = (i_index <= obj.index and (i_index+1)) or i_index
	POS[i_index*3-2] = (obj.x+obj.ox)
	POS[i_index*3-1] = (obj.y+obj.oy)
	POS[i_index*3  ] = (obj.z+obj.oz)
	POS.v[i_index] = {obj.x+obj.ox, obj.y+obj.oy, obj.z+obj.oz}
end


--/////////////////////////////////////////////////////////////////////////////
@TA-Anchour
--/////////////////////////////////////////////////////////////////////////////
--track0:progress,0,100,0
--track1:delay,0,100,0
--track2:order,0,4,0,1
--track3:scale,-1000,1000,100
--dialog:index指定/chk,local choose=0;└index,local ind={0,1,2,3,4,5,6};└indexｵﾌｾｯﾄ,local ad=0;pos,pos={0,0,0};seed,local sd=0;easing.No,local ease=0;
--++check0:配置初期化,0;
local function clamp(x) return (x<=0 and 0) or (x>=1 and 1) or x end
local function lerp(t,a,b) return t*(b-a)+a end
local function easing(x) return x*x*(3-2*x) end
if (ease) and (ease>0) then
	local E = require("easing")
	local easelist = {
		"linear",                                               -- 1
		"inSine",   "outSine",   "inOutSine",   "outInSine",    -- 2,3,4,5
		"inQuad",   "outQuad",   "inOutQuad",   "outInQuad",    -- 6,7,8,9
		"inCubic",  "outCubic",  "inOutCubic",  "outInCubic",   -- 10,11,12,13
		"inQuart",  "outQuart",  "inOutQuart",  "outInQuart",   -- 14,15,16,17
		"inQuint",  "outQuint",  "inOutQuint",  "outInQuint",   -- 18,19,20,21
		"inExpo",   "outExpo",   "inOutExpo",   "outInExpo",    -- 22,23,24,25
		"inCirc",   "outCirc",   "inOutCirc",   "outInCirc",    -- 26,27,28,29
		"inElastic","outElastic","inOutElastic","outInElastic", -- 30,31,32,33
		"inBack",   "outBack",   "inOutBack",   "outInBack",    -- 34,35,36,37
		"inBounce", "outBounce", "inOutBounce", "outInBounce"   -- 28,39,40,41
	}
	easing = function(x)
		return E[easelist[ease]](x,0,1,1)
	end
end

if (ease and ease<0) then
	local function f()
		return require"マルチベジエ軌道"
	end
	local a,MBLua = pcall(f)
	if (a) then
		easing = function(x)
		  	local Time = MBLua.calc(MBLua.get(-ease))
		  	if not (Time) then return x end
	  		local i,t = math.modf(x * #Time)
	  		return ((Time[i+1] or 1) - Time[i]) * t + Time[i]
  		end
	elseif (Bezier_flow.time) then
		easing = function(x)
			return Bezier_flow.time(-ease,x)
		end
	end
end

if not (Setmtx) then
	local function mtx(ang)
		local rad = math.pi/180
		ang = ang or {obj.rx,obj.ry,obj.rz}
		local cosx,sinx = math.cos(ang[1]*rad),math.sin(ang[1]*rad)
		local cosy,siny = math.cos(ang[2]*rad),math.sin(ang[2]*rad)
		local cosz,sinz = math.cos(ang[3]*rad),math.sin(ang[3]*rad)

		local function f(v)
			v[1],v[2] = (v[1]*cosz - v[2]*sinz),(v[1]*sinz + v[2]*cosz) -- z軸
			v[1],v[3] = (v[3]*siny + v[1]*cosy),(v[3]*cosy - v[1]*siny) -- y軸
			v[2],v[3] = (v[2]*cosx - v[3]*sinx),(v[2]*sinx + v[3]*cosx) -- x軸
			return v
		end

		return f
	end
	Setmtx = mtx
end
local Rotate = Setmtx()

local function shuffle_tbl(tbl,seed)
	local count = #tbl
	math.randomseed(seed or 0)
	local j
	for i = count,2,-1 do
		j = math.random(i)
		tbl[i], tbl[j] = tbl[j], tbl[i]
	end
	return tbl
end
--------------------------------------------------------------------------------
local v = {obj.ox,obj.oy,obj.oz}
local index,num = obj.index,obj.num
local ad,dc = math.modf(ad or 0)
for i=1,#ind do
	ind[i]=(ind[i]+ad)%obj.num
end
if (choose==1) then
	-- obj.indexをダイアログの設定順にしたindexに変更(オーダー設定用)
	num = #ind
	for i=0,#ind-1 do
		if ind[i+1]==obj.index then
			index = i
			break
		end
	end
else
	index = obj.index
	num = math.min(obj.num,16)
end

local Order = ({
	  [0] = function() return obj.index end,
		function() return obj.num-1-obj.index end,
		function()
				return math.abs((obj.num) - obj.index*2 - 1)
		end,
		function()
				return obj.num - math.abs((obj.num) - obj.index*2 - 1)
		end,
		function(seed)
			local id = {}
			for i=1,obj.num do id[i] = i-1 end
			return shuffle_tbl(id,seed)[obj.index+1]
		end
})

local Order = ({
	  [0] = function() return index end,
		function() return num-1-index end,
		function()
				return math.abs((num) - index*2 - 1)
		end,
		function()
				return num - math.abs((num) - index*2 - 1)
		end,
		function(seed)
			local id = {}
			for i=1,num do id[i] = i-1 end
			return shuffle_tbl(id,seed)[index+1] or obj.index
		end
})[obj.track2%5]

local id = Order(sd)
--------------------------------------------------------------------------------
local t     = obj.track0*0.01
local delay = obj.track1*0.01
local scale = obj.track3*0.01
local ox,oy,oz = obj.ox,obj.oy,obj.oz
t = easing(clamp( t*(1+delay*num) - delay*id))
if (choose==1) then
	if (obj.index==0) then
		obj.setanchor("pos",#ind)
	end
	for i=1,#ind do
		if (ind[i]==obj.index) then
			v = {
				pos[i*2-1],
				pos[i*2],
				oz}
				v = Rotate(v)
				obj.ox = lerp(t,obj.ox,v[1]*scale)
				obj.oy = lerp(t,obj.oy,v[2]*scale)
				obj.oz = lerp(t,obj.oz,v[3]*scale)
			break
		end
	end
else
	if (obj.index==0) then
		obj.setanchor("pos",num)
	end
	v = { pos[index*2+1] or obj.ox ,pos[index*2+2] or obj.oy ,oz }
	v = Rotate(v)
	obj.ox = lerp(t,obj.ox,v[1]*scale)
	obj.oy = lerp(t,obj.oy,v[2]*scale)
	obj.oz = lerp(t,obj.oz,v[3]*scale)
end


-- 座標情報をPOSで垂れ流し
if (obj.index==0) then
	POS = {}
	POS.v = {}
	i_index = 0
end
if (obj.ox) then
	i_index = (i_index <= obj.index and (i_index+1)) or i_index
	POS[i_index*3-2] = (obj.x+obj.ox)
	POS[i_index*3-1] = (obj.y+obj.oy)
	POS[i_index*3  ] = (obj.z+obj.oz)
	POS.v[i_index] = {obj.x+obj.ox, obj.y+obj.oy, obj.z+obj.oz}
end

--/////////////////////////////////////////////////////////////////////////////
@TA-Field
--/////////////////////////////////////////////////////////////////////////////
--track0:範囲,0,5000,200
--track1:Random,0,100,0
--track2:引/斥力,-1000,1000,0
--track3:波紋数,0,20,0
--dialog:ｱﾝｶｰ数,local num=1;レイヤー,local la={};色/col,local c1=0xf9344c;色強度,local c_s=200;透明度,local a_s=0;拡大率,local zm=0;移動方向,local vl={0,0,0};波紋速度,local spd=2;波紋ズレ%,local ofs=0;ｱﾝｶｰ位置,pos={0,0,0};
--check0:smooth,0
--色(範囲外)/col,local c2=nil;
local pi = math.pi
local function clamp(x) return (x<=0 and 0) or (x>=1 and 1) or x end
local function lerp(t,a,b) return t * (b-a) + a end
local function lerpv(t,a,b) return lerp(t,a[1],b[1]),lerp(t,a[2],b[2]),lerp(t,a[3],b[3]) end
local function linear(t,a,b,A,B) return clamp((t-a)/(b-a)) * (B-A) + A end

local function field(v, p, radius, strength, smooth, cycle, time, offset)
	cycle  = pi*2 * (cycle or 0)
	offset = pi*2 * (offset or 0)
	local f = (v.f or 0)
	local pv = {v[1]-p[1], v[2]-p[2], v[3]-p[3]}
	local d  = math.sqrt( pv[1]*pv[1] + pv[2]*pv[2] + pv[3]*pv[3] )
	if (d > 1e-08) and (d <= radius) then
		local l = d / radius
		local s = math.pow(1 - l, 1+smooth)
		if (cycle > 0) then
			s = s * (math.cos(l * cycle - time - offset - pi*0.5) + 1) * 0.5
		end
		local r = (radius - d) * s * strength
		r = math.max(r,-d) / d
		v[1] = v[1] + pv[1]*r
		v[2] = v[2] + pv[2]*r
		v[3] = v[3] + pv[3]*r
		if (s > f) then f = s end
	end
	v.f = f
	return v
end

num = math.min(num,8)
local p = {}
if (obj.index==0) then
	pos = pos or {0,0,0}
	obj.setanchor("pos",num,"xyz")

	-- if not (rikky_module) then
	-- 	pcall(require,"rikky_module")
	-- elseif (rikky_module) then
	-- 	for i=1,#pos do
	-- 		pos[i] = math.floor(pos[i])
	-- 	end
	-- 	rikky_module.setdialogparam("pos",pos)
	-- end

end

for i=1,num do
	p[i] = {pos[i*3-2],pos[i*3-1],pos[i*3]}
end

for i=1,#la do
	local x = obj.getvalue("layer"..(la[i])..".x")
	if x then
		p[#p+1] = {
			x - obj.x,
			obj.getvalue("layer"..(la[i])..".y") - obj.y,
			obj.getvalue("layer"..(la[i])..".z") - obj.z
		}
	end
end

local radius   = obj.track0
local random   = obj.track1 * 0.01
local strength = obj.track2 * 0.01
local cycle    = obj.track3
local time     = obj.time * (spd or 0)
local smooth   = obj.check0 and 1 or 0
if (cycle == 0) then time = 0 end

local v = {obj.ox, obj.oy, obj.oz, f = 0}
for i=1,#p do
	local rnd = lerp(random,1,obj.rand(0,100,(seed or 0),i) * 0.01)
	v = field(v, p[i], radius*rnd, strength, smooth, cycle, time, i/#p * ofs*0.01)
end

obj.ox   = v[1] + (vl[1] or 0) * v.f
obj.oy   = v[2] + (vl[2] or 0) * v.f
obj.oz   = v[3] + (vl[3] or 0) * v.f
obj.zoom = obj.zoom * math.max(0,obj.zoom + (v.f * zm*0.01))

if (a_s < 0) then
	a_s = (1-v.f) * -a_s*0.01
else
	a_s = v.f * a_s*0.01
end
obj.alpha = obj.alpha * clamp(1-a_s)

local color_strength = 0
if (c_s < 0) then
	color_strength = (1-v.f)
else
	color_strength = v.f
end

if (c1) then
	if not tostring(c1):find("table:") then c1={c1} end
	local grad_cycle = 1
	local loop_clamp = 1 -- or 0
	local l = #c1
	local i,t = math.modf(v.f * (l-loop_clamp) * grad_cycle)
	local col = RGB( lerpv(t, {RGB(c1[i%l+1])}, {RGB(c1[(i+1)%l+1])}) )
	obj.effect("単色化","color",col,"強さ",math.abs(c_s)*color_strength,"輝度を保持する",0)
end

-- 範囲変数垂れ流し
TA_F = v.f

-- 座標情報をPOSで垂れ流し
if (obj.index==0) then
	POS = {}
	POS.v = {}
	i_index = 0
end
if (obj.ox) then
	i_index = (i_index <= obj.index and (i_index+1)) or i_index
	POS[i_index*3-2] = (obj.x+obj.ox)
	POS[i_index*3-1] = (obj.y+obj.oy)
	POS[i_index*3  ] = (obj.z+obj.oz)
	POS.v[i_index] = {obj.x+obj.ox, obj.y+obj.oy, obj.z+obj.oz}
end


--/////////////////////////////////////////////////////////////////////////////
@TA-Effector
--/////////////////////////////////////////////////////////////////////////////
--track0:範囲,0,1000,30
--track1:フェード,0,2000,70
--track2:強度,-100,100,100,0.01
--track3:移動,-2000,2000,0
--dialog:レイヤー,layer={0};└ ｱﾝｶｰに変更,local il=1;点⇔線/chk,local line=0;└ 線分/chk,local segment=0;└ 片側(2D)/chk,oneside=0;拡大率,local zoom=100;透明度,local alp=100;ぼかし,local blur=0;色強度,local col_str=0;└ 色/col,local col=0xf9344c;└ 色(逆側)/col,local col2=0x1d86ae;移動方向,local dir={0,0,0};└ ランダム影響,local rnd={1,1,1};
--++dialog:レイヤー,layer={0};└ ｱﾝｶｰ/chk,local il=1;線判定/chk,local line=0;└ 1:線分 2:片側,local seg=0;拡大率,local zoom=100;透明度,local alp=100;ぼかし,local blur=0;色強度,local col_str=0;└ 色/col,local col=0xf9344c;└ 色(逆側)/col,local col2=0x1d86ae;移動方向,local dir={0,0,0};└ ランダム移動/chk,local rnd=0;
local obj = obj
-- 補間-------------------------------------------------------------------------
local function clamp(x) return (x<=0 and 0) or (x>=1 and 1) or x end
local function clampng(x) return (x<=-1 and -1) or (x>=1 and 1) or x end
local function lerp(t,a,b) return t*(b-a)+a end
local function linear(t,a,b,A,B) return clamp((t-a)/(b-a)) * (B-A)+A end
local function smooth(x) return x*x*(3-2*x) end
-- Vector簡易-------------------------------------------------------------------
 -- TA_Vector = nil
if (obj.index==0) and not (TA_Vector) then
	local V = {}
	local eps = 1e-08
	V.sub	= function(a,b) return {a[1]-b[1],a[2]-b[2],a[3]-b[3]} end
	V.add	= function(a,b) return {a[1]+b[1],a[2]+b[2],a[3]+b[3]} end
	V.scale	= function(v,x) return {v[1]*x,v[2]*x,v[3]*x} end
	V.mul	= function(a,b) return {a[1]*b[1],a[2]*b[2],a[3]*b[3]} end
	V.unm	= function(v) return {-v[1], -v[2], -v[3]} end
	V.div	= function(a,b) return {a[1]/b[1], a[2]/b[2], a[3]/b[3]} end
	V.len	= function(v) return (v[1]*v[1]+v[2]*v[2]+v[3]*v[3]) end
	V.lensq = function(a,b) return V.len( V.sub(a,b) ) end
	V.length = function(v) return (v[1]*v[1]+v[2]*v[2]+v[3]*v[3])^0.5 end
	V.normalize = function(v) local l=math.max(eps,V.length(v)); return {v[1]/l,v[2]/l,v[3]/l} end
	V.cross	= function(a,b) return  {a[2]*b[3]-a[3]*b[2],a[3]*b[1]-a[1]*b[3],a[1]*b[2]-a[2]*b[1]} end
	V.dot	= function(a,b) return (a[1]*b[1] + a[2]*b[2] + a[3]*b[3]) end
	V.slide = function(v,n) return V.add( v,V.scale(n,-V.dot(v,n) ) ) end
	V.reflect = function(v,n) return V.add( v,V.scale(n,-2*V.dot(v,n) ) ) end
	V.lerp = function(t,a,b) return { a[1]+(b[1]-a[1])*t, a[2]+(b[2]-a[2])*t, a[3]+(b[3]-a[3])*t } end
	V.clamp = function(v) return {clamp(v[1]),clamp(v[2]),clamp(v[3])} end

	V.sub2	= function(a,b) return {a[1]-b[1],a[2]-b[2]} end
	V.length2 = function(v) return (v[1]*v[1]+v[2]*v[2])^0.5 end
	V.dot2 = function(a,b) return (a[1]*b[1] + a[2]*b[2]) end

	-- 点Pと線ab上の最近点
	V.pos_on_line = function(p,a,b)
	    local N = V.normalize(V.sub(b,a)) 	--線abの単位ベクトル
	    local D = V.dot(N, V.sub(p,a))	--apベクトルと内積
	    return V.add(a,V.scale(N,D))
	end
	-- 点Pと線分ab上の最近点
	V.pos_on_segment = function(p,a,b)
	    if ( V.dot( V.sub(b,a),V.sub(p,a) ) < eps ) then
				return a
	    elseif ( V.dot( V.sub(b,a),V.sub(p,b) ) > eps ) then
				return b
	    else
				return V.pos_on_line(p,a,b)
	    end
	end
	-- 点Aと平面上の最近点(A=座標 p=平面上の点 n=平面の法線 )
	V.pos_on_plane = function(a,p,n)
		-- local PA = {a[1]-p[1],a[2]-p[2], a[3]-p[3]}
		-- local d = (n[1]*PA[1] + n[2]*PA[2] + n[3]*PA[3])
		-- return {a[1]-(n[1]*d), a[2]-(n[2]*d), a[3]-(n[3]*d)}
		  return V.sub(a, V.scale(n, V.dot(n,V.sub(a,p)) ) )
	end

	-- 点pと線abの距離(正負でどちら側か判定) 2Dのみ
	V.dist_line = function(p,a,b)
		local ab,ap = {b[1]-a[1],b[2]-a[2]}, {a[1]-p[1],a[2]-p[2]}
		local l = math.sqrt(ab[1]*ab[1] + ab[2]*ab[2])
		if (l == 0) then return 0 end
		return (ab[1]*ap[2]-ab[2]*ap[1]) / l -- ab,apの外積(面積)をabの長さで割る
	end

	-- 点pと線分abの距離(正負でどちら側か判定) 2Dのみ
	V.dist_segment = function(p,a,b)
		if ( V.dot2( V.sub2(b,a),V.sub2(p,a) ) < eps ) then
			return 0
		elseif ( V.dot2( V.sub2(b,a),V.sub2(p,b) ) > eps ) then
			return 0
		end
		return V.dist_line(p,a,b)
	end

	-- 線分abと平面nの交点( n=平面の法線, p=平面上の点)
	V.pos_intersection_segment_plane = function(a,b,p,n)
	  -- a + ベクトルab * ( paとnの内積 / (paとnの内積 + pbとnの内積) )
		-- p = V.scale(n,d)
		local d_pa = V.dot(V.sub(a,p),n)
		local d_pb = V.dot(V.sub(b,p),n)
		d_pa = (math.abs(d_pa) <= eps and 0) or d_pa
		d_pb = (math.abs(d_pb) <= eps and 0) or d_pb
		if (d_pa==0 and d_pa==0) then
			return false -- 両方の点が平面上
		elseif (d_pa >= 0 and d_pb <= 0) or ( d_pa <= 0 and d_pb >= 0 ) then
			return false -- 点が平面を跨いでいないので交点なし
		end
		local ratio = d_pa/(d_pa + d_pb)
		return V.add(a, V.scale( V.sub(b,a), ratio) )
	end

	TA_Vector = V
end

local V = TA_Vector
--[[
-- 回転 ------------------------------------------------------------------------
if not (Setmtx) and (obj.index==0) then
	local function mtx(ang)
		local rad = math.pi/180
		ang = ang or {obj.rx,obj.ry,obj.rz}
		local cosx,sinx = math.cos(ang[1]*rad),math.sin(ang[1]*rad)
		local cosy,siny = math.cos(ang[2]*rad),math.sin(ang[2]*rad)
		local cosz,sinz = math.cos(ang[3]*rad),math.sin(ang[3]*rad)

		local function f(v)
			v[1],v[2] = (v[1]*cosz - v[2]*sinz),(v[1]*sinz + v[2]*cosz) -- z軸
			v[1],v[3] = (v[3]*siny + v[1]*cosy),(v[3]*cosy - v[1]*siny) -- y軸
			v[2],v[3] = (v[2]*cosx - v[3]*sinx),(v[2]*sinx + v[3]*cosx) -- x軸
			return v
		end

		return f
	end
	Setmtx = mtx
end
local Rotate = Setmtx()

-- 球形の押し分け移動 -----------------------------------------------------------
local function Sphiricalfield(p,a,radius,strength,attract)
	local ap  = {p[1]-a[1],p[2]-a[2],p[3]-a[3]}
	local len = math.sqrt(ap[1]*ap[1] + ap[2]*ap[2] + ap[3]*ap[3])
	if (len <= 1e-08) then len = 1e-08 end
	if (attract~=1 and len<radius) or (attract==1 and len>radius) then
	local n = {ap[1]/len, ap[2]/len, ap[3]/len}
	local d = (radius - len) * strength
	d = math.max(d,-len) -- strengthがマイナスの場合は移動距離を限定する
	return {p[1]+n[1]*d, p[2]+n[2]*d, p[3]+n[3]*d}, 1-(len/radius)
	end
	return {p[1],p[2],p[3]},0
	end
]]

-- 指定したレイヤーの座標をテーブル化----------------------------------------------
local function Getpos(x)
	if x==0 then
		return {obj.x,obj.y,obj.z}
	end
	local l = "layer"..x
	if not obj.getvalue(l..".x") then
		return {obj.x,obj.y,obj.z}
	end
	return {obj.getvalue(l..".x"),obj.getvalue(l..".y"),obj.getvalue(l..".z")}
end

-- 本体=========================================================================

-- トラックバー,ダイアログ--------------------------------------------------------
local dist = obj.track0
local fade = obj.track1
local strength = obj.track2*0.01
local move_strength = obj.track3
alp = (alp or 0)*0.01
zoom = (zoom or 100)*0.01
blur = (blur or 0)
dir = dir or {}
rnd = rnd or {}
setmetatable( dir,{__index={0,0,0}} )
setmetatable( rnd,{__index={0,0,0}} )

--距離判定用の位置情報------------------------------------------------------------
-- カメラ位置
-- local cam = obj.getoption("camera_param")
-- cam.p = {cam.x,cam.y,cam.z}
-- cam.t = {cam.tx,cam.ty,cam.tz}
-- cam.v = V.sub(cam.t,cam.p)
-- cam.l = V.length(cam.v)
-- if cam.l==0 then cam.l = 1e-6 end
-- cam.n = V.scale(cam.v, 1/cam.l)

-- オブジェクトの位置
local zm = obj.getvalue("zoom")*0.01
local pos = {obj.x+obj.ox-obj.cx*zm, obj.y+obj.oy-obj.cy*zm, obj.z+obj.oz-obj.cz}

-- エフェクターの位置、複数ある場合に対応したいので入れ子状にテーブル化
local loc = {}
if (il==0) then -- レイヤー使用
	layer = layer or {0}
	for i=1,#layer do
		loc[i] = Getpos(layer[i])
	end
else -- アンカーポイント使用
	layer = layer or {}
	if (obj.index == 0) then
		if (line == 1) then
			obj.setanchor("layer",il*2,"xyz","line")
		else
			obj.setanchor("layer",il+1,"xyz")
		end
	end
	for i=1,#layer,3 do
		table.insert(loc,{layer[i]+obj.x,layer[i+1]+obj.y,layer[i+2]+obj.z})
	end
end

-- 距離計算&数値化---------------------------------------------------------------
local len,sum = 0,0
local v,v1 = 0,0
local vc,vt = {},{}

if (line==0) or (#loc==1) then
	-- 距離エフェクタ
	for i=1,#loc do
		len = V.length( V.sub(pos,loc[i]) )
		sum = linear(len,dist,dist+fade,1,0)
		v = (sum>=v) and (sum) or v -- v以上なら結果を更新
	end

elseif (oneside==1) then
	-- 線エフェクタ(2D,片側)
	if (segment==1) then
		 -- 線分
		for i=0,#loc-2,2 do
			len = V.dist_segment(pos,loc[i+1],loc[i+2])
			-- 線の法線ベクトルを保存して移動に使う
			table.insert(vc, V.normalize( { -(loc[i+2][2]-loc[i+1][2]),(loc[i+2][1]-loc[i+1][1]), 0} ))
			if (len<0) then
				-- マイナスの場合はv1を増加
				sum = linear(-len,dist,dist+fade,1,0)
				v1 = (sum>=v1) and (sum) or v1
				table.insert(vt,0)
			elseif (len>0 )then
				sum = linear(len,dist,dist+fade,1,0)
				v = (sum>=v) and (sum) or v
				table.insert(vt,v)
			else
				table.insert(vt,0)
			end
		end
	else
		-- 線
		for i=0,#loc-2,2 do
			len = V.dist_line(pos,loc[i+1],loc[i+2])
			-- 線の法線ベクトルを保存して移動に使う
			table.insert(vc, V.normalize( { -(loc[i+2][2]-loc[i+1][2]),(loc[i+2][1]-loc[i+1][1]), 0} ))
			if (len<0) then
				-- マイナスの場合はv1を増加
				sum = linear(-len,dist,dist+fade,1,0)
				v1 = (sum>=v1) and (sum) or v1
				table.insert(vt,0)
			else
				sum = linear(len,dist,dist+fade,1,0)
				v = (sum>=v) and (sum) or v
				table.insert(vt,v)
			end
		end
	end
	if (strength<0) then
		v1 = 1-v1
	end
	v1 = v1 * (strength)
	v1 = v1*v1*(3-2*v1)

else
	-- 線エフェクタ
	if (segment==1) then
		-- 線分
		for i=0,#loc-2,2 do
			local p = V.pos_on_segment(pos,loc[i+1],loc[i+2])
			len = V.length(V.sub(pos,p))
			sum = linear(len,dist,dist+fade,1,0)
			v = (sum>=v) and (sum) or v
		end
	else
		-- 線
		for i=0,#loc-2,2 do
			local p = V.pos_on_line(pos,loc[i+1],loc[i+2])
			len = V.length(V.sub(pos,p))
			sum = linear(len,dist,dist+fade,1,0)
			v = (sum>=v) and (sum) or v
		end
	end

end

-- strengthがマイナスなら動作反転
if (strength<0) then v = 1-v end
strength = math.abs(strength)
-- スムーズ化
-- v = v*v*((v*v*16 - v*v*10)-v*v*6)
v = v*v*strength

-- エフェクト操作 ---------------------------------------------------------------

-- ダイアログ設定の透明度はトラックバーの動作と同じに。100で透明化
obj.alpha = obj.alpha * lerp(alp*strength, 1, (1-v))

-- ダイアログ設定の拡大率はトラックバーの動作と同じに。100だと等倍
obj.zoom  = obj.zoom * lerp(v*strength, 1, zoom)

-- 単色化、ダイアログの色の設定が空欄だと無視する。
if (col_str>0) then
	if (col) then
		obj.effect("単色化","輝度を保持する",0,"color",col,"強さ",col_str*v)
	end
	if (col2) then
		if (oneside==1) then -- 線(片側)
			obj.effect("単色化","輝度を保持する",0,"color",col2,"強さ",col_str*v1)
		else
			obj.effect("単色化","輝度を保持する",0,"color",col2,"強さ",col_str*(strength-v))
		end
	end
end

-- ぼかし、マイナスだとレンズブラー
if (blur>0) then
	obj.effect("ぼかし","範囲",blur*v)
elseif (blur<0) then
	obj.effect("レンズブラー","範囲",-blur*v,"サイズ固定",0)
end

-- 移動、取り敢えずランダムにしてしまった
if (move_strength~=0) then
	if (oneside==1) then
		local ox,oy = obj.ox,obj.oy
		for i=1,#vc do
			-- 定方向に移動
			if vt[i]>0 then
				obj.ox = lerp(vt[i]*strength, ox, obj.ox - vc[i][1] * move_strength)
				obj.oy = lerp(vt[i]*strength, oy, obj.oy - vc[i][2] * move_strength)
			end
		end
	end
	obj.ox = obj.ox + (dir[1] + clampng(obj.rand(-1000,1000,   1,1)*0.001 * rnd[1])) * move_strength * v
	obj.oy = obj.oy + (dir[2] + clampng(obj.rand(-1000,1000, 100,1)*0.001 * rnd[2])) * move_strength * v
	obj.oz = obj.oz + (dir[3] + clampng(obj.rand(-1000,1000,1000,1)*0.001 * rnd[3])) * move_strength * v
end

-- 計算結果を垂れ流し。
TA_E = v
TA_E1 = v1

-- 座標情報をPOSで垂れ流し
if (obj.index==0) then
	POS = {}
	POS.v = {}
	i_index = 0
end
if (obj.ox) then
	i_index = (i_index <= obj.index and (i_index+1)) or i_index
	POS[i_index*3-2] = (obj.x+obj.ox)
	POS[i_index*3-1] = (obj.y+obj.oy)
	POS[i_index*3  ] = (obj.z+obj.oz)
	POS.v[i_index] = {obj.x+obj.ox, obj.y+obj.oy, obj.z+obj.oz}
end
--==============================================================================
-- 計算結果を他のスクリプトで使う
--[[
require("rikky_module")
local b = rikky_module.bordering(4)
local ox,oy,oz =obj.ox-obj.cx,obj.oy-obj.cy,obj.oz
obj.copybuffer("tmp","obj")
local vri=vi*0.03 -- ランダム度
local d=100 --奥行
if vi>0 then
	obj.draw(0,0,0,1,1-vi)
	obj.draw(0,0,d,1,1-vi)
	obj.load("figure","四角形",0xf9344c,2)
	obj.ox,obj.oy,obj.oz=ox,oy,oz
	for i=1,#b do
		for j=1,#b[i],2 do
			local jj = (j+1)%#b[i]+1
			local ex,ey = rand(-100,100,1,j)*vri,rand(-100,100,2,j)*vri
			local x0,y0 = b[i][j]+ex, b[i][j+1]+ey
			local x1,y1 = b[i][jj]+ex, b[i][jj+1]+ey
			obj.draw(x0,y0,0,1,vi*vi)
			obj.putpixel(0,0,0xf9344c,vi*vi)
			obj.drawpoly(x0,y0,d, x1,y1,d, x1,y1,0,x0,y0,0, 0,0, 0,0, 0,0, 0,0)
		end
	end
end
obj.copybuffer("obj","tmp")
]]


-- 個別オブジェクト(オブジェクト分割)にダイレクトに面を張ってみる
--[[
local l = 10 -- 横分割数と合わせる
if(obj.index==0)then t={} end
local w,h=obj.getpixel()
local col,alp=obj.getpixel(w/2,h/2)
t[obj.index]={obj.ox,obj.oy,obj.oz,obj.alpha*alp,col=col}
if(obj.index==obj.num-1)then
	obj.draw()
	obj.ox,obj.oy,obj.oz = 0,0,0
	obj.alpha,obj.zoom = 0.8,1
	for i=0,#t-l do
		if(i%l~=l-1)then --右端と左端の接続を回避
			local a,b,c,d =t[i],t[i+1],t[i+1+l],t[i+l]
			obj.putpixel(0,0,a.col,1)
			obj.drawpoly(
				a[1],a[2],a[3],
				b[1],b[2],b[3],
				c[1],c[2],c[3],
				c[1],c[2],c[3],
				0,0, 0,0, 0,0, 0,0, a[4]*b[4]*c[4]
			)
			obj.putpixel(0,0,d.col,1)
			obj.drawpoly(
				a[1],a[2],a[3],
				c[1],c[2],c[3],
				d[1],d[2],d[3],
				d[1],d[2],d[3],
				0,0, 0,0, 0,0, 0,0,a[4]*c[4]*d[4]
			)
		end
	end
end
]]
--/////////////////////////////////////////////////////////////////////////////
@TA-DepthEffector
--/////////////////////////////////////////////////////////////////////////////
--track0:焦点範囲,0,5000,100
--track1:フェード,0.1,5000,100
--track2:焦点前後,-2000,2000,0
--track3:強度,-100,100,100
--dialog:ぼかし,local blur=10;レンズブラ-/chk,local lens=0;拡大率影響,local zoom=100;透明度影響,local alpha=0;色強度,local col_str=100;色(奥)/col,local f_col=0xf9344c;色(手前)/col,local n_col=0x1d86ae;ランダム移動,local rnd={0, 0, 0}
--check0:焦点を目標に固定,0

local function lerp(t,a,b) return t*(b-a)+a end
local function clamp(t) return (t<=0 and 0) or (t>=1 and 1) or (t) end
-- 回転 ------------------------------------------------------------------------
if not (Setmtx) then
	local function mtx(ang)
		local rad = math.pi/180
		ang = ang or {obj.rx,obj.ry,obj.rz}
		local cosx,sinx = math.cos(ang[1]*rad),math.sin(ang[1]*rad)
		local cosy,siny = math.cos(ang[2]*rad),math.sin(ang[2]*rad)
		local cosz,sinz = math.cos(ang[3]*rad),math.sin(ang[3]*rad)
		local function f(v)
			v[1],v[2] = (v[1]*cosz - v[2]*sinz),(v[1]*sinz + v[2]*cosz) -- z軸
			v[1],v[3] = (v[3]*siny + v[1]*cosy),(v[3]*cosy - v[1]*siny) -- y軸
			v[2],v[3] = (v[2]*cosx - v[3]*sinx),(v[2]*sinx + v[3]*cosx) -- x軸
			return v
		end
		return f
	end
	Setmtx = mtx
end
local Rotate = Setmtx()

-- トラックバーとダイアログ=======================================================
local start      = obj.track0
local fade       = obj.track1
local focalpoint = obj.track2
local strength   = obj.track3*0.01
local near_start = start
local near_fade  = fade
alpha = (alpha or 0)*0.01
zoom = (zoom or 100)*0.01
if fade<=0 then fade = 0.1 end

-- 中心点の回転移動を座標に含める処理==============================================
local zm = obj.getvalue("zoom")*0.01
local cx,cy,cz = unpack( Rotate({obj.cx*zm,obj.cy*zm,obj.cz}) )

-- 距離計算 =====================================================================
local cam = obj.getoption("camera_param")
-- カメラ平面用の単位ベクトル(法線)nを作る(画面奥向き)
local n = {0, 0, 1}
local cv = {cam.tx-cam.x,cam.ty-cam.y,cam.tz-cam.z}
local l = math.sqrt(cv[1]*cv[1] + cv[2]*cv[2] + cv[3]*cv[3])
if (l>0) then
	n = {cv[1]/l, cv[2]/l, cv[3]/l}
end
-- カメラ平面用の距離Dを設定。拡張編集の初期値は1024
local D = (obj.check0) and (l+focalpoint) or (1024+focalpoint)
-- カメラ平面上にある点pを作る。Dの値で平面を前後に移動
local p = {n[1]*D, n[2]*D, n[3]*D}

-- オブジェクトの位置はカメラ原点にする為カメラの位置を引いておく
local pos = {
	obj.x+obj.ox-cx - cam.x,
	obj.y+obj.oy-cy - cam.y,
	obj.z+obj.oz-cz - cam.z
}
-- 点p→オブジェクトposベクトルpv
local pv = {pos[1]-p[1], pos[2]-p[2], pos[3]-p[3]}
-- カメラ平面の法線nとpvのドット積が距離 (奥ならプラス、手前ならマイナス)
local distance = (n[1]*pv[1] + n[2]*pv[2] + n[3]*pv[3])

if (distance<0) then
  start,fade = near_start,near_fade
end
-- 距離は絶対値
local depth = math.abs(distance)-start
-- ０~１クランプ
depth = (depth<0 and 0) or (depth>fade and fade) or depth
-- フェードで割って単位化
depth = (depth/fade)

-- 強度がマイナスならdepthを反転してから強度を絶対値に
if (strength<0) then depth = (1-depth) end
strength = math.abs(strength)

if (alpha>=0) then
	obj.alpha = obj.alpha * clamp( (1-depth * alpha) * strength)
else
	obj.alpha = obj.alpha * clamp( (depth  * -alpha) * strength)
end

obj.zoom  = obj.zoom + lerp(depth,0,math.max(-1,zoom*strength))

if (distance>0) then
	if (f_col) then obj.effect("単色化","輝度を保持する",0,"強さ",col_str*depth*strength,"color",f_col) end
else
	if (n_col) then obj.effect("単色化","輝度を保持する",0,"強さ",col_str*depth*strength,"color",n_col) end
end

if (lens==1) then
	obj.effect("レンズブラー","範囲",blur*depth*strength,"サイズ固定",0)
else
	obj.effect("ぼかし","範囲",blur*depth*strength)
end

local dist = distance/(start+fade) * strength*0.01 * depth
obj.ox = obj.ox + obj.rand(-1000,1000,   1,obj.index)*0.1 * (rnd[1] or 0) * dist
obj.oy = obj.oy + obj.rand(-1000,1000, 100,obj.index)*0.1 * (rnd[2] or 0) * dist
obj.oz = obj.oz + obj.rand(-1000,1000,1000,obj.index)*0.1 * (rnd[3] or 0) * dist

-- 座標情報をPOSで垂れ流し
if (obj.index==0) then
	POS = {}
	POS.v = {}
	i_index = 0
end
if (obj.ox) then
	i_index = (i_index <= obj.index and (i_index+1)) or i_index
	POS[i_index*3-2] = (obj.x+obj.ox)
	POS[i_index*3-1] = (obj.y+obj.oy)
	POS[i_index*3  ] = (obj.z+obj.oz)
	POS.v[i_index] = {obj.x+obj.ox, obj.y+obj.oy, obj.z+obj.oz}
end

-- 結果を垂れ流し
TA_D = depth
TA_D1 = distance

--/////////////////////////////////////////////////////////////////////////////
@TA-Noise
--/////////////////////////////////////////////////////////////////////////////
--track0:スケール,0,1000,50,0.01
--track1:移動,-5000,5000,0,0.01
--track2:透明度,0,100,0,0.01
--track3:拡大率,0,100,0,0.01
--dialog:オクターブ,local oct=2;└ 細かさ,local lac=2;└ 強度,local gain=0.25;風向き,local wind={0, 0, 0};移動影響軸,local vec={1, 1, 1};└ 強度乗算,local amp=1;evolution,local evo=0;ﾉｲｽﾞｵﾌｾｯﾄ,local offset={0,0,0};ｺﾝﾄﾗｽﾄ%,local contrast=0;
--check0:global,0;

if not (PerlinNoise) then ------------------------------------------------------
	-- original code by Ken Perlin: http://mrl.nyu.edu/~perlin/noise/
	local noise = {}
	local p = {}
	local permutation = {151,160,137,91,90,15,
		88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
		77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
		102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
		190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
		223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
		131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
		129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
		251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
		135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
		5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
		49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
		138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180
	}

	for i=0,255 do
		p[i] = permutation[i+1]
		p[256+i] = permutation[i+1]
	end

	local function round(x)
		if (x>0) then
			return math.floor(x+0.5)
		else
			return -math.floor(-x+0.5)
		end
	end

	local function fade(t)
		return t * t * t * (t * (t * 6 - 15) + 10)
	end

	local function lerp(t, a, b)
		return a + t * (b - a)
	end

	local function grad(hash, x, y, z)
		local h = hash % 16
		local u = h < 8 and x or y
		local v = h < 4 and y or ((h == 12 or h == 14) and x or z)
		return ((h % 2) == 0 and u or -u) + ((h % 3) == 0 and v or -v)
	end

	local function rot(x,y,ang)
		local cosz,sinz = math.cos(ang),math.sin(ang)
		return {(x*cosz - y*sinz),(x*sinz + y*cosz)}
	end

	function noise.perlin(x, y, z)
		y = y or 2
		z = z or 3
		local X,x = math.modf(x % 256)
		local Y,y = math.modf(y % 256)
		local Z,z = math.modf(z % 256)
		local u = fade(x)
		local v = fade(y)
		local w = fade(z)

		local A   = p[X    ] + Y
		local AA  = p[A    ] + Z
		local AB  = p[A + 1] + Z
		local B   = p[X + 1] + Y
		local BA  = p[B    ] + Z
		local BB  = p[B + 1] + Z

	  	return  lerp(w, lerp(v, lerp(u, grad(p[AA    ], x    , y    , z    ),
	                                 	grad(p[BA    ], x - 1, y    , z    )),
	                         	lerp(u, grad(p[AB    ], x    , y - 1, z    ),
	                                 	grad(p[BB    ], x - 1, y - 1, z    ))),
	                 	lerp(v, lerp(u, grad(p[AA + 1], x    , y    , z - 1),
	                                 	grad(p[BA + 1], x - 1, y    , z - 1)),
	                         	lerp(u, grad(p[AB + 1], x    , y - 1, z - 1),
	                                 	grad(p[BB + 1], x - 1, y - 1, z - 1))))
	end

	function noise.fbm(x, y, z, octaves, lacunarity, gain)
		octaves = octaves or 2
		lacunarity = lacunarity or 2
		gain = gain or 0.25
		local amplitude = 1
		local frequency = 1
		local sum = 0.01
		for i = 0, octaves do
			sum = sum + amplitude *
			noise.perlin(
				x * frequency,
				y * frequency,
				z * frequency
			)
			amplitude = amplitude * gain
			frequency = frequency * lacunarity
		end
		return sum
	end

	function noise.fbmrot(x, y, z, octaves, lacunarity, gain, rotation, subrotation)
		octaves = math.floor(octaves or 2)
		lacunarity = lacunarity or 2
		rotation = rotation or 0
		subrotation = subrotation or 0
		gain = gain or 0.25
		local amplitude = 1
		local frequency = 1
		local sum = 0.01
		x,y = rot(x,y,rotation)
		for i = 0, octaves do
			local xr,yr = rot(x,y, subrotation*i)
				sum = sum + amplitude *
				noise.perlin(
				x * frequency + xr-x,
				y * frequency + yr-y,
				z * frequency
			)
			amplitude = amplitude * gain
			frequency = frequency * lacunarity
		end
	return sum
end

	PerlinNoise = noise
end
--------------------------------------------------------------------------------
local noise = PerlinNoise
local function clamp(x) return (x<=0 and 0) or (x>=1 and 1) or x end
local function lerp(t,a,b) return t*(b-a) + a end
local function linear(t,a,b,A,B) return clamp((t-a)/(b-a)) * (B-A) + A end
setmetatable(offset,{__index={0,0,0}})
setmetatable(wind,{__index={0,0,0}})
setmetatable(vec,{__index={1,1,1}})

local scale  = obj.track0*0.0001
local amount = obj.track1
local alpha  = obj.track2*0.01
local zoom   = obj.track3*0.01
local global = (obj.check0 and 1) or 0
oct = (oct or 0)
lac = (lac or 2)
gain = (gain or 0.25)
if (lac==0) then oct = 0 end
if (gain==0) then oct = 0 end
amp = (amp or 1)

-- 時間に逆数をかけて風速を一定っぽくする(出来てない)
local time = obj.time -- / (1+obj.track0*0.1) * 100
evo = evo * time * 0.01

local x = (obj.x*global + obj.ox + (-wind[1]*time) + offset[1]) * scale
local y = (obj.y*global + obj.oy + ( wind[2]*time) + offset[2]) * scale
local z = (obj.z*global + obj.oz + ( wind[3]*time) + offset[3]) * scale
local nx = noise.fbm(x+16    ,y+32,    z+64+evo ,oct,lac,gain)
local ny = noise.fbm(x+64+evo,y+16,    z+32     ,oct,lac,gain)
local nz = noise.fbm(x+32    ,y+64+evo,z+16     ,oct,lac,gain)

-- nx = linear(nx,-contrast,contrast,-1,1)
-- ny = linear(ny,-contrast,contrast,-1,1)
-- nz = linear(nz,-contrast,contrast,-1,1)
obj.ox = obj.ox + nx * amount * amp * vec[1]
obj.oy = obj.oy + ny * amount * amp * vec[2]
obj.oz = obj.oz + nz * amount * amp * vec[3]

contrast = clamp(1 - (contrast or 0.4) * 0.01)
local na = linear(nx,-contrast,contrast,0,1 )
obj.alpha = obj.alpha * lerp(alpha,1, na )
obj.zoom  = obj.zoom  * lerp(clamp(zoom) , 1, na )

-- 座標情報をPOSで垂れ流し
if (obj.index==0) then
	POS = {}
	POS.v = {}
	i_index = 0
end
if (obj.ox) then
	i_index = (i_index <= obj.index and (i_index+1)) or i_index
	POS[i_index*3-2] = (obj.x+obj.ox)
	POS[i_index*3-1] = (obj.y+obj.oy)
	POS[i_index*3  ] = (obj.z+obj.oz)
	POS.v[i_index] = {obj.x+obj.ox, obj.y+obj.oy, obj.z+obj.oz}
end

-- 結果を垂れ流し
TA_NX = nx
TA_NY = ny
TA_NZ = nz

--/////////////////////////////////////////////////////////////////////////////
@TA-Gradation
--/////////////////////////////////////////////////////////////////////////////
--track0:Offset,-1200,1200,0
--track1:Cycle,0,9000,100
--track2:強度,0,100,100
--track3:範囲指定,0,4,0,1
--dialog:合成モード[-1/12],local blend=0;明るめ補間/chk,local rms=0;色1/col,local c1=0xff0048;色2/col,local c2=0xfe5252;色3/col,local c3=0xa2ccea;色4/col,local c4=0xeee0ef;色逆順/chk,local rev=0;色loop/chk,local loop=0;アンカー,pos={-100,0,100,0};└ Z回転と同期/chk,local rt=0;track,local tr={0,0,0}
--check0:グラデーション,1
-- preset = {0x8e8e8e,0xf6d5a4,0x900014,0x172e52}
local lerp
if (rms==0) then
	lerp = function(t,a,b) return a + (b-a)*t end
else
	lerp = function(t,a,b) return math.sqrt(a*a*(1-t) + b*b*t) end
end

local function vlerp(t,a,b)
	return lerp(t,a[1],b[1]), lerp(t,a[2],b[2]), lerp(t,a[3],b[3])
end

local function clamp(x)
	return (x<=0 and 0) or (x>=1 and 1) or x
end

local function rotz(v,rt)
	if (rt == 0) then return v end
	local r = math.rad(obj.getvalue("rz"))
	local sz,cz = math.sin(r),math.cos(r)
	return {v[1]*cz-v[2]*sz,v[1]*sz+v[2]*cz, v[3]*cz-v[4]*sz,v[3]*sz+v[4]*cz}
end

local function torgb(tbl,col)
	if not col then return end
	if not tostring(col):find("table:") then
		col = {col}
	end
	for i=1,#col do
		table.insert(tbl, { RGB(col[i]) } )
	end
end

local color = {}
	torgb(color,c1)
	torgb(color,c2)
	torgb(color,c3)
	torgb(color,c4)

if (rev == 1) then
	local tmp={}
	for i=0,#color-1 do
		tmp[i+1] = color[#color-i]
	end
	color = tmp
end

if not tostring(tr):find("table:") then tr = {tr} end
setmetatable(tr,{__index={0,0,0,0}})

local l = #color
local offset = -(obj.track0+tr[1])*0.01 % 1 * l
local cycle  =  (obj.track1+tr[2])*0.01
local id = obj.index / math.max(obj.num-1,1)
local strength = (obj.track2 + tr[3])

local mode = obj.track3
if (mode >= 1) then
	if (obj.index == 0) then obj.setanchor("pos",2,"line") end
	local zm = obj.getvalue("zoom") * 0.01
	pos = rotz({pos[1]*zm,pos[2]*zm,pos[3]*zm,pos[4]*zm},rt)
	local ab = {pos[3]-pos[1], pos[4]-pos[2]}
	local ap = {obj.ox-pos[1], obj.oy-pos[2]}
	local len = (ab[1]*ab[1] + ab[2]*ab[2])
	if (len < 1e-06 ) then len = 1e-06 end
	local d = math.sqrt( (ap[1]*ap[1] + ap[2]*ap[2]) / len)
	id = -(-ab[2]*ap[2] - ab[1]*ap[1]) / len
	-- id = math.abs(ab[1]*ap[2] - ab[2]*ap[1]) / len -- 線上
	id = ( {clamp(d), d, clamp(id), math.abs(id)} )[mode]
end

local col
if (obj.check0) then
	loop = 1-loop
	local k,t = math.modf(id * (l-loop) * cycle + offset)
	col = RGB( vlerp(t,color[k%l+1],color[(k+1)%l+1]) )
else
	local k
	k = math.floor(id * (l-1) * cycle + offset + 0.5)
	col = RGB( color[k%l+1][1], color[k%l+1][2], color[k%l+1][3] )
end

local ilum = 0
if (blend == -1) then
	ilum = 1
	blend = 0
end
blend = blend%13
if (blend==0) then
	obj.effect("単色化","強さ",strength,"color",col,"輝度を保持する",ilum)
else
	obj.effect("グラデーション","強さ",strength,"color",col,"color2",col,"blend",blend)
end

-- 結果を垂れ流し
TA_G = id
